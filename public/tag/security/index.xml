<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>security | knrt10&#39;s Blog</title>
    <link>/tag/security/</link>
      <atom:link href="/tag/security/index.xml" rel="self" type="application/rss+xml" />
    <description>security</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><copyright>knrt10 Â© 2021. [Site source code](https://github.com/knrt10/blog)</copyright><lastBuildDate>Sat, 30 Jan 2021 00:00:00 +0000</lastBuildDate>
    <image>
      <url>/images/icon_hudaf87b0bbf6edf362efcd690a86c5023_625_512x512_fill_lanczos_center_2.png</url>
      <title>security</title>
      <link>/tag/security/</link>
    </image>
    
    <item>
      <title>Seccomp security profiles for Docker</title>
      <link>/post/seccomp-security-profiles-docker/</link>
      <pubDate>Sat, 30 Jan 2021 00:00:00 +0000</pubDate>
      <guid>/post/seccomp-security-profiles-docker/</guid>
      <description>&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;nav id=&#34;TableOfContents&#34;&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;#what-is-seccomp&#34;&gt;What is Seccomp?&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#how-docker-uses-seccomp&#34;&gt;How docker uses Seccomp?&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#creating-out-own-seccomp-profile-json-file&#34;&gt;Creating out own seccomp profile json file&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#conclusion&#34;&gt;Conclusion&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#did-you-find-this-page-helpful-consider-sharing-it-&#34;&gt;Did you find this page helpful? Consider sharing it ðŸ™Œ&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;
&lt;h2 id=&#34;what-is-seccomp&#34;&gt;What is Seccomp?&lt;/h2&gt;
&lt;p&gt;As per the &lt;a href=&#34;https://www.kernel.org/doc/Documentation/prctl/seccomp_filter.txt&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;kernel documentation&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A large number of system calls are exposed to every userland process
with many of them going unused for the entire lifetime of the process.
As system calls change and mature, bugs are found and eradicated.  A
certain subset of userland applications benefit by having a reduced set
of available system calls.  The resulting set reduces the total kernel
surface exposed to the application.  System call filtering is meant for
use with those applications.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Seccomp filtering provides a means for a process to specify a filter for
incoming system calls.  The filter is expressed as a Berkeley Packet
Filter (BPF) program, as with socket filters, except that the data
operated on is related to the system call being made: system call
number and the system call arguments.  This allows for expressive
filtering of system calls using a filter program language with a long
history of being exposed to userland and a straightforward data set.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;how-docker-uses-seccomp&#34;&gt;How docker uses Seccomp?&lt;/h2&gt;
&lt;p&gt;Secure computing mode &lt;code&gt;(seccomp)&lt;/code&gt; is a Linux kernel feature. You can use it to restrict the actions available within the container. The &lt;code&gt;seccomp()&lt;/code&gt; system call operates on the seccomp state of the calling process. You can use this feature to restrict your applicationâ€™s access.&lt;/p&gt;
&lt;p&gt;This feature is available only if Docker has been built with seccomp and the kernel is configured with &lt;code&gt;CONFIG_SECCOMP&lt;/code&gt; enabled. To check if your kernel supports seccomp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ grep CONFIG_SECCOMP= /boot/config-$(uname -r)
CONFIG_SECCOMP=y
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The default &lt;code&gt;seccomp&lt;/code&gt; profile provides a sane default for running containers with seccomp and disables around &lt;code&gt;44&lt;/code&gt; system calls out of &lt;code&gt;300+&lt;/code&gt;. It is moderately protective while providing wide application compatibility. The default Docker profile can be found &lt;a href=&#34;https://github.com/moby/moby/blob/master/profiles/seccomp/default.json&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;seccomp&lt;/code&gt; is instrumental for running Docker containers with least privilege. It is not recommended to change the default seccomp profile.&lt;/p&gt;
&lt;p&gt;When you run a container, it uses the default profile unless you override it with the &lt;code&gt;--security-opt&lt;/code&gt; option. For example, the following explicitly specifies a policy:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker run --rm \
  -it \
  --security-opt seccomp=/path/to/seccomp/profile.json \
  hello-world
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let&amp;rsquo;s take a look at snippet of syscalls allowed from the default profile:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;names&amp;quot;: [
    &amp;quot;bpf&amp;quot;,
    &amp;quot;clone&amp;quot;,
    &amp;quot;fanotify_init&amp;quot;,
    &amp;quot;lookup_dcookie&amp;quot;,
    &amp;quot;mount&amp;quot;,
    &amp;quot;name_to_handle_at&amp;quot;,
    &amp;quot;perf_event_open&amp;quot;,
    &amp;quot;quotactl&amp;quot;,
    &amp;quot;setdomainname&amp;quot;,
    &amp;quot;sethostname&amp;quot;,
    &amp;quot;setns&amp;quot;,
    &amp;quot;syslog&amp;quot;,
    &amp;quot;umount&amp;quot;,
    &amp;quot;umount2&amp;quot;,
    &amp;quot;unshare&amp;quot;
  ],
  &amp;quot;action&amp;quot;: &amp;quot;SCMP_ACT_ALLOW&amp;quot;,
  &amp;quot;args&amp;quot;: [],
  &amp;quot;comment&amp;quot;: &amp;quot;&amp;quot;,
  &amp;quot;includes&amp;quot;: {
    &amp;quot;caps&amp;quot;: [
        &amp;quot;CAP_SYS_ADMIN&amp;quot;
    ]
  },
  &amp;quot;excludes&amp;quot;: {}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;names&lt;/code&gt; field in above json snippet refers to syscalls of linux kernel. They are only allowed for containers that you run with capability &lt;code&gt;CAP_SYS_ADMIN&lt;/code&gt; mentioned in &lt;code&gt;action&lt;/code&gt; json field. You can pass this capability to a container using &lt;code&gt;--cap-add&lt;/code&gt; flag.&lt;/p&gt;
&lt;h2 id=&#34;creating-out-own-seccomp-profile-json-file&#34;&gt;Creating out own seccomp profile json file&lt;/h2&gt;
&lt;p&gt;One thing to know is that every executable binary in unix system has some capabilities assigned to it. For example if you want to find capabilities assined to &lt;code&gt;ping&lt;/code&gt; binary just use &lt;code&gt;getcap&lt;/code&gt; command like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ getcap $(which ping)
/usr/bin/ping = cap_net_admin,cap_net_raw+p
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So what we will do that, is we will be tying &lt;code&gt;CAP_AUDIT_CONTROL&lt;/code&gt; capability to our &lt;code&gt;chown&lt;/code&gt; syscall. You can take any other capability other than &lt;code&gt;CAP_CHOWN&lt;/code&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This is purely for experimenting and understanding how seccomp profile will work. DO NOT use it in production environment.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;To make this work we will remove all the occurances of &lt;code&gt;chown&lt;/code&gt; syscall from &lt;a href=&#34;https://github.com/moby/moby/blob/master/profiles/seccomp/default.json&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;default&lt;/a&gt; seccomp profile and move it to our custom profile like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;{
  &amp;quot;names&amp;quot;: [
    &amp;quot;chown&amp;quot;,
    &amp;quot;chown32&amp;quot;,
    &amp;quot;fchown&amp;quot;,
    &amp;quot;fchown32&amp;quot;,
    &amp;quot;fchownat&amp;quot;,
    &amp;quot;lchown&amp;quot;,
    &amp;quot;lchown32&amp;quot;
  ],
  &amp;quot;action&amp;quot;: &amp;quot;SCMP_ACT_ALLOW&amp;quot;,
  &amp;quot;args&amp;quot;: [],
  &amp;quot;comment&amp;quot;: &amp;quot;&amp;quot;,
  &amp;quot;includes&amp;quot;: {
    &amp;quot;caps&amp;quot;: [
      &amp;quot;CAP_AUDIT_CONTROL&amp;quot;
    ]
  },
  &amp;quot;excludes&amp;quot;: {}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Final &lt;code&gt;json&lt;/code&gt; file can be &lt;a href=&#34;https://gist.github.com/knrt10/4c877585947f34fbfcab7626f3e7229c&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;found here&lt;/a&gt;. Copy it from github gist and save it as &lt;code&gt;custom-profile.json&lt;/code&gt; because it will be used in our next step for running docker container. Run the below command:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ docker run --rm -it --security-opt seccomp=custom-profile.json debian bash

# Try creating a user
root@429a518f8ec5:/# useradd knrt10
useradd: failure while writing changes to /etc/passwd
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Above command will fail as &lt;code&gt;useradd&lt;/code&gt; syscall uses &lt;code&gt;CAP_CHOWN&lt;/code&gt; internally. That is different topic, I will write an article about it another time.&lt;/p&gt;
&lt;p&gt;Now exit and try to run the docker container using this command:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ docker run --cap-add=CAP_AUDIT_CONTROL --rm -it --security-opt seccomp=custom-profile.json debian bash

# create a new user
root@ea95510fcb7c:/# useradd -m knrt10

# check current user i.e root
root@ea95510fcb7c:/# id -u
0

# create a file
root@ea95510fcb7c:/# touch a

# check permissions on file. Note currently it is owned by root
root@ea95510fcb7c:/# ls -l a
-rw-r--r-- 1 root root 0 Jan 30 11:21 a

# change ownership to earlier created user
root@ea95510fcb7c:/# chown knrt10 a

# check permissions on file. It is changed to user knrt10
root@ea95510fcb7c:/# ls -l a
-rw-r--r-- 1 knrt10 root 0 Jan 30 11:21 a
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When running the docker container by explicitly specifying the capability &lt;code&gt;CAP_AUDIT_CONTROL&lt;/code&gt; and then the container allows and uses syscall &lt;code&gt;chown&lt;/code&gt;. In this way you can create your own profile and tie it up with any capability you want.&lt;/p&gt;
&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;You learnt how seccomp profiles are used by docker and how you can create a custom seccomp profile and use it while running your docker container. This is mostly used for security purposes when you don&amp;rsquo;t want your container to have extra kernel priviledges. You can learn more in details from &lt;a href=&#34;https://docs.docker.com/engine/security/seccomp/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;docker&lt;/a&gt; documentation.&lt;/p&gt;
&lt;h2 id=&#34;did-you-find-this-page-helpful-consider-sharing-it-&#34;&gt;Did you find this page helpful? Consider sharing it ðŸ™Œ&lt;/h2&gt;
</description>
    </item>
    
    <item>
      <title>Learning about Pod Security Policy</title>
      <link>/post/psp/</link>
      <pubDate>Sat, 02 Jan 2021 00:00:00 +0000</pubDate>
      <guid>/post/psp/</guid>
      <description>&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;nav id=&#34;TableOfContents&#34;&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;#what-we-will-learn&#34;&gt;What we will learn&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#what-is-pod-security-policy&#34;&gt;What is Pod Security Policy?&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#pod-security-policies-allow-you-to-control&#34;&gt;Pod Security Policies allow you to control:&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#enabling-pod-security-policies&#34;&gt;Enabling Pod Security Policies&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#policy-order&#34;&gt;Policy order&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#creating-custom-kubernetes-pod-security-policy&#34;&gt;Creating Custom Kubernetes Pod Security Policy&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#set-up&#34;&gt;Set up&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#create-a-policy&#34;&gt;Create a policy&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#grant-access-to-service-account&#34;&gt;Grant access to Service Account&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#create-a-pod-using-custom-psp&#34;&gt;Create a pod using custom psp&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#pro-tip&#34;&gt;Pro Tip&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#did-you-find-this-page-helpful-consider-sharing-it-&#34;&gt;Did you find this page helpful? Consider sharing it ðŸ™Œ&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;
&lt;h2 id=&#34;what-we-will-learn&#34;&gt;What we will learn&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;What is a PSP?&lt;/li&gt;
&lt;li&gt;How to enable and use PSP in a cluster(minikube)&lt;/li&gt;
&lt;li&gt;Create custom psp and use it in a pod&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;what-is-pod-security-policy&#34;&gt;What is Pod Security Policy?&lt;/h2&gt;
&lt;p&gt;Pod Security Policies are cluster-wide resources that control security sensitive aspects of pod specification. PSP objects define a set of conditions that a pod must run with in order to be accepted into the system, as well as defaults for their related fields. PodSecurityPolicy is an optional admission controller that is enabled by default through the API, thus policies can be deployed without the PSP admission plugin enabled. This functions as a validating and mutating controller simultaneously.&lt;/p&gt;
&lt;h3 id=&#34;pod-security-policies-allow-you-to-control&#34;&gt;Pod Security Policies allow you to control:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;The running of privileged containers&lt;/li&gt;
&lt;li&gt;Usage of host namespaces&lt;/li&gt;
&lt;li&gt;Usage of host networking and ports&lt;/li&gt;
&lt;li&gt;Usage of volume types&lt;/li&gt;
&lt;li&gt;Usage of the host filesystem&lt;/li&gt;
&lt;li&gt;A white list of Flexvolume drivers&lt;/li&gt;
&lt;li&gt;The allocation of an FSGroup that owns the podâ€™s volumes&lt;/li&gt;
&lt;li&gt;Requirments for use of a read only root file system&lt;/li&gt;
&lt;li&gt;The user and group IDs of the container&lt;/li&gt;
&lt;li&gt;Escalations of root privileges&lt;/li&gt;
&lt;li&gt;Linux capabilities, SELinux context, AppArmor, seccomp, sysctl profile&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If youâ€™re interested in more details, check out the &lt;a href=&#34;https://kubernetes.io/docs/concepts/policy/pod-security-policy/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;official Kubernetes documentation&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;enabling-pod-security-policies&#34;&gt;Enabling Pod Security Policies&lt;/h2&gt;
&lt;p&gt;For learning purpose we will be testing on our minikube cluster.&lt;/p&gt;
&lt;p&gt;Enable &lt;code&gt;PodSecurityPolicy&lt;/code&gt; on your minikube cluster by appening &lt;code&gt;PodSecurityPolicy&lt;/code&gt; to the apiserver flag in minikube like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;--extra-config=apiserver.enable-admission-plugins=PodSecurityPolicy
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Important&lt;/strong&gt;: As per kubernetes documentation&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Pod security policy control is implemented as an optional (but recommended) admission controller. PodSecurityPolicies are enforced by enabling the admission controller, but doing so without authorizing any policies will prevent any pods from being created in the cluster. Since the pod security policy API (policy/v1beta1/podsecuritypolicy) is enabled independently of the admission controller, for existing clusters it is recommended that policies are added and authorized before enabling the admission controller.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This means if your start your cluster without adding and authorizing policies it will fail to start any new pod. To see this in working, follow below steps:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Start your minikube cluster without any policies defined
minikube start -p kautilya-cluster --kubernetes-version=v1.19.6 --feature-gates=EphemeralContainers=true --extra-config=apiserver.enable-admission-plugins=PodSecurityPolicy --addons=pod-security-policy

# Try running a simple pod
kubectl run nginx --image=nginx
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The above command will fail with the follwing output:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Error from server (Forbidden): pods &amp;quot;nginx&amp;quot; is forbidden: PodSecurityPolicy: no providers available to validate pod request&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;To fix the above problem you have to create a &lt;code&gt;psp.yaml&lt;/code&gt; file inside &lt;code&gt;~/.minikube/files/etc/kubernetes/addons&lt;/code&gt; folder. This will fix the issue when the cluster is being bootstraped. Copy the contents of file below and run the command:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;mkdir -p ~/.minikube/files/etc/kubernetes/addons &amp;amp;&amp;amp; \
cat &amp;lt;&amp;lt;EOF | tee ~/.minikube/files/etc/kubernetes/addons/psp.yaml | kubectl apply -f -
---
apiVersion: policy/v1beta1
kind: PodSecurityPolicy
metadata:
  name: privileged
  annotations:
    seccomp.security.alpha.kubernetes.io/allowedProfileNames: &amp;quot;*&amp;quot;
  labels:
    addonmanager.kubernetes.io/mode: EnsureExists
spec:
  privileged: true
  allowPrivilegeEscalation: true
  allowedCapabilities:
  - &amp;quot;*&amp;quot;
  volumes:
  - &amp;quot;*&amp;quot;
  hostNetwork: true
  hostPorts:
  - min: 0
    max: 65535
  hostIPC: true
  hostPID: true
  runAsUser:
    rule: &#39;RunAsAny&#39;
  seLinux:
    rule: &#39;RunAsAny&#39;
  supplementalGroups:
    rule: &#39;RunAsAny&#39;
  fsGroup:
    rule: &#39;RunAsAny&#39;
---
apiVersion: policy/v1beta1
kind: PodSecurityPolicy
metadata:
  name: restricted
  labels:
    addonmanager.kubernetes.io/mode: EnsureExists
spec:
  privileged: false
  allowPrivilegeEscalation: false
  requiredDropCapabilities:
    - ALL
  volumes:
    - &#39;configMap&#39;
    - &#39;emptyDir&#39;
    - &#39;projected&#39;
    - &#39;secret&#39;
    - &#39;downwardAPI&#39;
    - &#39;persistentVolumeClaim&#39;
  hostNetwork: false
  hostIPC: false
  hostPID: false
  runAsUser:
    rule: &#39;MustRunAsNonRoot&#39;
  seLinux:
    rule: &#39;RunAsAny&#39;
  supplementalGroups:
    rule: &#39;MustRunAs&#39;
    ranges:
      # Forbid adding the root group.
      - min: 1
        max: 65535
  fsGroup:
    rule: &#39;MustRunAs&#39;
    ranges:
      # Forbid adding the root group.
      - min: 1
        max: 65535
  readOnlyRootFilesystem: false
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: psp:privileged
  labels:
    addonmanager.kubernetes.io/mode: EnsureExists
rules:
- apiGroups: [&#39;policy&#39;]
  resources: [&#39;podsecuritypolicies&#39;]
  verbs:     [&#39;use&#39;]
  resourceNames:
  - privileged
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: psp:restricted
  labels:
    addonmanager.kubernetes.io/mode: EnsureExists
rules:
- apiGroups: [&#39;policy&#39;]
  resources: [&#39;podsecuritypolicies&#39;]
  verbs:     [&#39;use&#39;]
  resourceNames:
  - restricted
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: default:restricted
  labels:
    addonmanager.kubernetes.io/mode: EnsureExists
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: psp:restricted
subjects:
- kind: Group
  name: system:authenticated
  apiGroup: rbac.authorization.k8s.io
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: default:privileged
  namespace: kube-system
  labels:
    addonmanager.kubernetes.io/mode: EnsureExists
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: psp:privileged
subjects:
- kind: Group
  name: system:masters
  apiGroup: rbac.authorization.k8s.io
- kind: Group
  name: system:nodes
  apiGroup: rbac.authorization.k8s.io
- kind: Group
  name: system:serviceaccounts:kube-system
  apiGroup: rbac.authorization.k8s.io
EOF
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let&amp;rsquo;s check the PSPs created:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;kubectl get psp
NAME         PRIV    CAPS   SELINUX    RUNASUSER          FSGROUP     SUPGROUP    READONLYROOTFS   VOLUMES
privileged   true    *      RunAsAny   RunAsAny           RunAsAny    RunAsAny    false            *
restricted   false          RunAsAny   MustRunAsNonRoot   MustRunAs   MustRunAs   false            configMap,emptyDir,projected,secret,downwardAPI,persistentVolumeClaim

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now if you try to create a pod, it will be created successfully.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;kubectl run nginx --image=nginx
pod/nginx created
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: One thing you need to see which psp is assigned to the pod. Run the command below:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;kubectl describe po nginx | grep kubernetes.io/psp
Annotations:  kubernetes.io/psp: privileged
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see that &lt;code&gt;privileged&lt;/code&gt; psp is assigned to it. Buy why privileged? That&amp;rsquo;s where policy order come in action.&lt;/p&gt;
&lt;h3 id=&#34;policy-order&#34;&gt;Policy order&lt;/h3&gt;
&lt;p&gt;As per kubernetes documentation, it says:&lt;/p&gt;
&lt;p&gt;In addition to restricting pod creation and update, pod security policies can also be used to provide default values for many of the fields that it controls. When multiple policies are available, the pod security policy controller selects policies according to the following criteria:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;PodSecurityPolicies which allow the pod as-is, without changing defaults or mutating the pod, are preferred. The order of these non-mutating PodSecurityPolicies doesn&amp;rsquo;t matter.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If the pod must be defaulted or mutated, the first PodSecurityPolicy (ordered by name) to allow the pod is selected.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;Understanding this policy order is a black hole. More your experiment more you go into the black hole. So one thing you need to keep in mind is that you need to match the &lt;code&gt;po.spec&lt;/code&gt; and &lt;code&gt;psp.spec&lt;/code&gt; and if more than 2 policies match the criterion, the policy which comes first will be selected. To understand more, we will try to create a custom policy and run it in our pod.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;creating-custom-kubernetes-pod-security-policy&#34;&gt;Creating Custom Kubernetes Pod Security Policy&lt;/h2&gt;
&lt;h3 id=&#34;set-up&#34;&gt;Set up&lt;/h3&gt;
&lt;p&gt;Set up a namespace and a service account to act as for this example. We&amp;rsquo;ll use this service account which will have access to our custom psp and use this inside our pod.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;kubectl create namespace testing-psp
kubectl create serviceaccount -n testing-psp testing-psp
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;create-a-policy&#34;&gt;Create a policy&lt;/h3&gt;
&lt;p&gt;Define the &lt;code&gt;minimal-psp-restricted&lt;/code&gt; PodSecurityPolicy object. This is a policy that simply prevents the creation of privileged pods, and run user as non root. The name of a PodSecurityPolicy object must be a valid &lt;a href=&#34;https://kubernetes.io/docs/concepts/overview/working-with-objects/names#dns-subdomain-names&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DNS subdomain name&lt;/a&gt;. Run the below command:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;cat &amp;lt;&amp;lt;EOF | kubectl apply -f -
apiVersion: policy/v1beta1
kind: PodSecurityPolicy
metadata:
  name: minimal-psp-restricted
spec:
  privileged: false  # Don&#39;t allow privileged pods!
  # The rest fills in some required fields.
  seLinux:
    rule: RunAsAny
  supplementalGroups:
    rule: RunAsAny
  runAsUser:
    rule: MustRunAsNonRoot
  fsGroup:
    rule: RunAsAny
  volumes:
  - &#39;*&#39;
EOF
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Check the psp created:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;kubectl get psp
NAME                     PRIV    CAPS   SELINUX    RUNASUSER          FSGROUP     SUPGROUP    READONLYROOTFS   VOLUMES
minimal-psp-restricted   false          RunAsAny   MustRunAsNonRoot   RunAsAny    RunAsAny    false            *
privileged               true    *      RunAsAny   RunAsAny           RunAsAny    RunAsAny    false            *
restricted               false          RunAsAny   MustRunAsNonRoot   MustRunAs   MustRunAs   false            configMap,emptyDir,projected,secret,downwardAPI,persistentVolumeClaim

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;grant-access-to-service-account&#34;&gt;Grant access to Service Account&lt;/h3&gt;
&lt;p&gt;Our Service Account &lt;code&gt;testing-psp&lt;/code&gt; should  have permission to use the new policy. To check whether it has access run the command:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;kubectl auth can-i use podsecuritypolicy/minimal-psp-restricted --as=&amp;quot;system:serviceaccount:testing-psp:testing-psp&amp;quot;
no
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Create the rolebinding to grant service account &lt;code&gt;testing-psp&lt;/code&gt; the use &lt;code&gt;verb&lt;/code&gt; on the &lt;code&gt;minimal-psp-restricted&lt;/code&gt; policy:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Create a role
kubectl create role psp:minimalunprivileged \
    --verb=use \
    --resource=podsecuritypolicy \
    --resource-name=minimal-psp-restricted \
    --namespace=testing-psp

role.rbac.authorization.k8s.io/psp:minimalunprivileged created

# Create a rolebinding
kubectl create rolebinding psp:minimalunprivilegedbinding \
    --role=psp:minimalunprivileged \
    --serviceaccount=testing-psp:testing-psp \
    --namespace=testing-psp

rolebinding.rbac.authorization.k8s.io/psp:minimalunprivilegedbinding created

# Check access to use psp
kubectl auth can-i use podsecuritypolicy/minimal-psp-restricted --as=&amp;quot;system:serviceaccount:testing-psp:testing-psp&amp;quot;
yes
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;create-a-pod-using-custom-psp&#34;&gt;Create a pod using custom psp&lt;/h3&gt;
&lt;p&gt;Let us create a pod using our service account. Run the file below:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;cat &amp;lt;&amp;lt;EOF | kubectl apply -f -
apiVersion: v1
kind: Pod
metadata:
  labels:
    run: nginx
  name: nginx
spec:
  serviceAccountName: testing-psp
  containers:
  - image: nginx
    name: nginx
    resources: {}
    securityContext:
      runAsNonRoot: true # container should run as roon root
      runAsUser: 65534 # this means running as nobody
      runAsGroup: 65534 # this means running as nogroup
  dnsPolicy: ClusterFirst
  restartPolicy: Always
status: {}
EOF
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Once the pod is created, let us check which psp is assigned to it&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;kubectl describe po nginx | grep kubernetes.io/psp
Annotations:  kubernetes.io/psp: minimal-psp-restricted
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see that it is using our custom psp &lt;code&gt;minimal-psp-restricted&lt;/code&gt; because &lt;code&gt;po.spec&lt;/code&gt; for our &lt;code&gt;nginx&lt;/code&gt; pod matches &lt;code&gt;psp.spec&lt;/code&gt; fields from &lt;code&gt;minimal-psp-restricted&lt;/code&gt; policy.&lt;/p&gt;
&lt;p&gt;Thatâ€™s it. Youâ€™ve created and applied your first Kubernetes pod security policy. With the help of this technique, you can greatly enhance the security of your Kubernetes deployments.&lt;/p&gt;
&lt;h3 id=&#34;pro-tip&#34;&gt;Pro Tip&lt;/h3&gt;
&lt;p&gt;When creating a custom policy, always start with privileged psp and then start changing fields for &lt;code&gt;po.spec&lt;/code&gt; according to changes in your policy. This can help you in debugging.&lt;/p&gt;
&lt;h2 id=&#34;did-you-find-this-page-helpful-consider-sharing-it-&#34;&gt;Did you find this page helpful? Consider sharing it ðŸ™Œ&lt;/h2&gt;
</description>
    </item>
    
    <item>
      <title>Passing CKA exam</title>
      <link>/post/cka/</link>
      <pubDate>Fri, 25 Dec 2020 00:00:00 +0000</pubDate>
      <guid>/post/cka/</guid>
      <description>&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;nav id=&#34;TableOfContents&#34;&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;#how-it-started&#34;&gt;How it started&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#how-i-practiced&#34;&gt;How I practiced&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#explaining-the-whole-process&#34;&gt;Explaining the whole process&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#whats-in-the-exam&#34;&gt;What&amp;rsquo;s in the exam?&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#basic-understanding-of-systemd&#34;&gt;Basic Understanding of systemd&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#networking&#34;&gt;Networking&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#linux-commands&#34;&gt;Linux Commands&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#k8s-imperative-commands&#34;&gt;k8s Imperative Commands&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#k8s-components&#34;&gt;k8s Components&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#practice&#34;&gt;Practice&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#browser-terminal-setup&#34;&gt;Browser Terminal Setup&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#minimal-setup&#34;&gt;Minimal Setup&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#be-fast&#34;&gt;Be fast&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#cka-preparation&#34;&gt;CKA Preparation&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#read-the-curriculum&#34;&gt;Read the Curriculum&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#read-the-handbook&#34;&gt;Read the Handbook&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#read-the-important-tips&#34;&gt;Read the important tips&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#read-the-faq&#34;&gt;Read the FAQ&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#conclusion&#34;&gt;Conclusion&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#did-you-find-this-page-helpful-consider-sharing-it-&#34;&gt;Did you find this page helpful? Consider sharing it ðŸ™Œ&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;
&lt;h2 id=&#34;how-it-started&#34;&gt;How it started&lt;/h2&gt;
&lt;p&gt;After doing a good amount of internships I started my first job working as &lt;strong&gt;Cloud Infrastructure Engineer&lt;/strong&gt; at &lt;a href=&#34;https://kinvolk.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kinvolk&lt;/a&gt;. Initially when I started the job I had little experience with Kubernetes, I had only worked on setting up cluster on &lt;a href=&#34;https://cloud.google.com/kubernetes-engine&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GKE&lt;/a&gt; or worked on pre-setup clusters like &lt;a href=&#34;https://minikube.sigs.k8s.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;minikube&lt;/a&gt;. When I started the job I worked on our product &lt;a href=&#34;https://github.com/kinvolk/lokomotive&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Lokomotive&lt;/a&gt; which is an open source Kubernetes distribution that ships pure upstream Kubernetes. It focuses on being minimal, easy to use, and secure by default. While working on that I got into deeper details of Kubernetes Infrastructure. Since then I have been trying to learn as much as I can into greater detail.&lt;/p&gt;
&lt;h2 id=&#34;how-i-practiced&#34;&gt;How I practiced&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;I did not took any course or followed any professional training. I mostly prefer going though documentation and practicing it. Rest it&amp;rsquo;s up to you how you proceed. My day to day work is regarging k8s only but I did practice for 2 weeks for CKA exam to solve questions in time limit.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I have a &lt;strong&gt;Mackbook air 2017 model with 8gb RAM&lt;/strong&gt;. So why am I telling this?&lt;/p&gt;
&lt;p&gt;It&amp;rsquo;s because my laptop has gone to dust, it was hard for me to practice on my laptop. My situation currently is if I start a minikube cluster and open vscode on side, it takes some 20-30 seconds for just a file to save. Initially when my laptop somehow did not lag, I used to spun up Vagrant ubuntu machine to practice but that idea went to drain once I laptop started lagging more. To fix this problem what I did was that I used to spun up &lt;code&gt;t1.small.x86&lt;/code&gt; machine on &lt;a href=&#34;https://console.equinix.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Equinix Metal&lt;/a&gt;(Formerly Packet) and practice there.&lt;/p&gt;
&lt;h2 id=&#34;explaining-the-whole-process&#34;&gt;Explaining the whole process&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;You first buy the exam anytime from &lt;a href=&#34;https://www.cncf.io/certification/cka/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;official CNCF website&lt;/a&gt;. After that you have 1 year to take the exam before it expires&lt;/li&gt;
&lt;li&gt;You then schedule the exam within 1 year of time frame after you bought it&lt;/li&gt;
&lt;li&gt;You then give the exam online while been proctored. Before beginning of the exam the proctor checks all the criteria is met as per rules and after that only exam is started&lt;/li&gt;
&lt;li&gt;You complete the exam&lt;/li&gt;
&lt;li&gt;You get result after 36-48 hours of exam&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;whats-in-the-exam&#34;&gt;What&amp;rsquo;s in the exam?&lt;/h2&gt;
&lt;p&gt;The exam consists of &lt;strong&gt;15-20&lt;/strong&gt; questions, you are supposed to complete these questions in &lt;strong&gt;2 hours&lt;/strong&gt; and you have to score &lt;strong&gt;66%&lt;/strong&gt; or more in order to pass the exam. You are allowed to open only two browser tabs, one will be the exam interface and in the other tab you can open any of the allowed web pages, one of them is &lt;a href=&#34;http://docs.kubernetes.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;k8s official docs&lt;/a&gt;. You can get a list of all the link that you can visit, in the candidates handbook and it says you can access &lt;a href=&#34;https://kubernetes.io/docs/,&#34;&gt;https://kubernetes.io/docs/,&lt;/a&gt; &lt;a href=&#34;https://github.com/kubernetes/&#34;&gt;https://github.com/kubernetes/&lt;/a&gt; and &lt;a href=&#34;https://kubernetes.io/blog&#34;&gt;https://kubernetes.io/blog&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Candidateâ€™s handbook says that you can copy 1â€“2 lines of data from the official documentation and thatâ€™s sufficient, you wont actually need to copy entire yaml file into your test. Its better to generate that yaml file by yourself and then edit that yaml file to have specific details.&lt;/p&gt;
&lt;p&gt;As most of you are aware the CKA exam requires a considerable amount of preparation since it focuses on practical/hands-on questions/scenarios rather than a set of Mutiple choice questions.&lt;/p&gt;
&lt;h2 id=&#34;basic-understanding-of-systemd&#34;&gt;Basic Understanding of systemd&lt;/h2&gt;
&lt;p&gt;There are chances that some of the component of the cluster will be running as linux services and not as k8s pods, and you might have to debug those components to check any issues in them. So it will always be a plus to have good understanding of how to change configuration of, check logs(&lt;strong&gt;journalctl&lt;/strong&gt;) of, start or stop a &lt;a href=&#34;https://www.freedesktop.org/wiki/Software/systemd/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;systemd&lt;/a&gt; service. You can easily learn from their official documentation.&lt;/p&gt;
&lt;h2 id=&#34;networking&#34;&gt;Networking&lt;/h2&gt;
&lt;p&gt;One of the most important thing in any distributed systems is Networking. I went little deep into it and learnt and practiced about:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Switch routing(interfaces, routes, gateways)&lt;/li&gt;
&lt;li&gt;DNS&lt;/li&gt;
&lt;li&gt;Network Namespaces&lt;/li&gt;
&lt;li&gt;Docker Networking&lt;/li&gt;
&lt;li&gt;CNI&lt;/li&gt;
&lt;li&gt;Cluster Networking&lt;/li&gt;
&lt;li&gt;Pod and Service Networking&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You should also be aware of some linux networking commands for example &lt;strong&gt;nslookup, ping, curl or dig&lt;/strong&gt; in order to check the connectivity between the hosts or components.&lt;/p&gt;
&lt;p&gt;This becomes very handy, if you have questions where you have to check the connectivity between the services or pods.&lt;/p&gt;
&lt;h2 id=&#34;linux-commands&#34;&gt;Linux Commands&lt;/h2&gt;
&lt;p&gt;You will be working on linux based machines so itâ€™s always beneficial to know some basic command of linux based operating systems. For example how to redirect output to a file (&amp;gt;), filter somethings from a file (grep), find, get last or first rows from the output and cut command. Practice &lt;code&gt;awk&lt;/code&gt; command and you should also know how processes work.&lt;/p&gt;
&lt;h2 id=&#34;k8s-imperative-commands&#34;&gt;k8s Imperative Commands&lt;/h2&gt;
&lt;p&gt;When you are asked to, letâ€™s say create a pod, itâ€™s not very ideal to write the entire manifests manually because its time consuming and you are likely to make some indention mistakes while writing the yaml. So its better to have the basic manifest of the resource generated and then edit that manifest with what is actually required by the question. More information can be found in &lt;a href=&#34;https://kubernetes.io/docs/concepts/overview/working-with-objects/object-management/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;k8s docs&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;k8s-components&#34;&gt;k8s Components&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;The other part is understanding Kubernetes components and being able to fix and investigate clusters. Understand this: &lt;a href=&#34;https://kubernetes.io/docs/tasks/debug-application-cluster/debug-cluster&#34;&gt;https://kubernetes.io/docs/tasks/debug-application-cluster/debug-cluster&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;When you have to fix a component (like kubelet) in one cluster, just check how its setup on another node in the same or even another cluster. You can copy config files over etc&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;I suggest you do &lt;a href=&#34;https://github.com/kelseyhightower/kubernetes-the-hard-way&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes The Hard Way&lt;/a&gt; once. It&amp;rsquo;s not necessary to do it more often or know it all by heart, the CKA is not that complex. But KTHW helps understanding the concepts&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;It can help if you install your own cluster using kubeadm in a VM or using a cloud provider and investigate the components. &lt;strong&gt;I did it myself in a vagrant setup&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Know how to use kubeadm to for example add nodes to a cluster&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Know how to create an Ingress resources&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Know how to snapshot/restore ETCD from another machine&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Know advanced scheduling: &lt;a href=&#34;https://kubernetes.io/docs/concepts/scheduling/kube-scheduler&#34;&gt;https://kubernetes.io/docs/concepts/scheduling/kube-scheduler&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;practice&#34;&gt;Practice&lt;/h2&gt;
&lt;p&gt;Practice is key to everything, the exam is totally based on questions that you will have to perform on live cluster. So until and unless you have actually done those things on live cluster before it will be hard for you but if you have done some practice/hands on you donâ€™t have to worry much about this.&lt;/p&gt;
&lt;p&gt;The best way to practice k8s concepts is to get minikube installed and go through the &lt;a href=&#34;https://kubernetes.io/docs/tasks/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;tasks&lt;/a&gt; page of the official k8s docs. Once you have gone through the official k8s docs tasks you will be confident enough to appear in the exam.&lt;/p&gt;
&lt;p&gt;There is no easy way out with the preparation practice, practice and sheer practice is the key to success here. Also a very economical usage of time and a personal strategy on how to target each question would greatly help crack this exam.&lt;/p&gt;
&lt;h2 id=&#34;browser-terminal-setup&#34;&gt;Browser Terminal Setup&lt;/h2&gt;
&lt;p&gt;It should be considered to spend ~1 minute in the beginning to setup your terminal. In the real exam the vast majority of questions will be done from the main terminal. For few you might need to ssh into another machine. Just be aware that configurations to your shell will not be transferred in this case.&lt;/p&gt;
&lt;h3 id=&#34;minimal-setup&#34;&gt;Minimal Setup&lt;/h3&gt;
&lt;h4 id=&#34;alias&#34;&gt;Alias&lt;/h4&gt;
&lt;p&gt;You might have read in most of the articles to set up aliases for the exam. But personally I find it useless. I would suggest to minimally setup this alias:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;echo &#39;alias kc=&amp;quot;kubectl&amp;quot;&#39; &amp;gt;&amp;gt; ~/.bashrc &amp;amp;&amp;amp; source ~/.bashrc &amp;amp;&amp;amp; echo &amp;quot;source &amp;lt;(kubectl completion bash)&amp;quot; &amp;gt;&amp;gt; ~/.bashrc &amp;amp;&amp;amp; complete -F __start_kubectl kc
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;vim&#34;&gt;Vim&lt;/h4&gt;
&lt;p&gt;Be great with vim.&lt;/p&gt;
&lt;h5 id=&#34;toggle-vim-line-numbers&#34;&gt;toggle vim line numbers&lt;/h5&gt;
&lt;p&gt;When in &lt;em&gt;vim&lt;/em&gt; you can press &lt;strong&gt;Esc&lt;/strong&gt; and type &lt;code&gt;:set number&lt;/code&gt; or &lt;code&gt;:set nonumber&lt;/code&gt; followed by &lt;strong&gt;Enter&lt;/strong&gt; to toggle line numbers. This can be useful when finding syntax errors based on line - but can be bad when wanting to mark&amp;amp;copy by mouse. You can also just jump to a line number with &lt;code&gt;Esc :22 + Enter&lt;/code&gt;.&lt;/p&gt;
&lt;h5 id=&#34;indent-multiple-lines&#34;&gt;Indent multiple lines&lt;/h5&gt;
&lt;p&gt;To indent multiple lines press Esc and type &lt;code&gt;:set shiftwidth=2&lt;/code&gt;. First mark multiple lines using &lt;code&gt;Shift v&lt;/code&gt; and the &lt;code&gt;up/down&lt;/code&gt; keys. Then to indent the marked lines press &lt;code&gt;&amp;gt; or &amp;lt;&lt;/code&gt;. You can then press &lt;code&gt;.&lt;/code&gt; to repeat the action.&lt;/p&gt;
&lt;p&gt;Also optionally you can create the file &lt;code&gt;~/.vimrc&lt;/code&gt; with the following content:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;set tabstop=2
set expandtab
set shiftwidth=2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;em&gt;expandtab&lt;/em&gt; make sure to use spaces for tabs. Memorize these and just type them down. You can&amp;rsquo;t have any written notes with commands on your desktop etc.&lt;/p&gt;
&lt;h2 id=&#34;be-fast&#34;&gt;Be fast&lt;/h2&gt;
&lt;p&gt;Use the &lt;code&gt;history&lt;/code&gt; command to reuse already entered commands or use even faster history search through &lt;code&gt;Ctrl r&lt;/code&gt; .&lt;/p&gt;
&lt;p&gt;If a command takes some time to execute, like sometimes &lt;code&gt;kubectl delete pod x&lt;/code&gt;. You can put a task in the background using &lt;code&gt;Ctrl z&lt;/code&gt; and pull it back into foreground running command &lt;code&gt;fg&lt;/code&gt; or run &lt;code&gt;bg&lt;/code&gt; to run in background while you perform other tasks.&lt;/p&gt;
&lt;p&gt;You can delete pods fast with:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;kc delete pod x --grace-period 0 --force
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;cka-preparation&#34;&gt;CKA Preparation&lt;/h2&gt;
&lt;h3 id=&#34;read-the-curriculum&#34;&gt;Read the Curriculum&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/cncf/curriculum&#34;&gt;https://github.com/cncf/curriculum&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;read-the-handbook&#34;&gt;Read the Handbook&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.linuxfoundation.org/tc-docs/certification/lf-candidate-handbook&#34;&gt;https://docs.linuxfoundation.org/tc-docs/certification/lf-candidate-handbook&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;read-the-important-tips&#34;&gt;Read the important tips&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.linuxfoundation.org/tc-docs/certification/tips-cka-and-ckad&#34;&gt;https://docs.linuxfoundation.org/tc-docs/certification/tips-cka-and-ckad&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;read-the-faq&#34;&gt;Read the FAQ&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.linuxfoundation.org/tc-docs/certification/faq-cka-ckad&#34;&gt;https://docs.linuxfoundation.org/tc-docs/certification/faq-cka-ckad&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;I would say it&amp;rsquo;s pretty easy if you have practiced and have good understanding how k8s works and how it is setup. It would help you while debugging and seting up cluster. Try &lt;strong&gt;solving questions with most weightage first&lt;/strong&gt;. Relax and do not feel pressure about the time. Also you should keep in mind that &lt;strong&gt;&lt;code&gt;CKA is just a tag&lt;/code&gt;&lt;/strong&gt;. Kubernetes is very vast, so you should try to learn it as much as you can if you are interested in working in distributed systems domain.&lt;/p&gt;
&lt;h2 id=&#34;did-you-find-this-page-helpful-consider-sharing-it-&#34;&gt;Did you find this page helpful? Consider sharing it ðŸ™Œ&lt;/h2&gt;
</description>
    </item>
    
  </channel>
</rss>
