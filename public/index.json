[{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":1608882896,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"/author/kautilya-tripathi/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/author/kautilya-tripathi/","section":"authors","summary":"","tags":null,"title":"Kautilya Tripathi","type":"authors"},{"authors":["Kautilya Tripathi"],"categories":["opensource"],"content":"This is Article 2 for this series. You can find first article here. Our task now is to setup our graphQL API and work with it.\nTable of Contents  About this Article GraphQL is the better REST Data Fetching with REST vs GraphQL No more Over and Underfetching  Overfetching: Downloading superfluous data Underfetching and the n+1 problem   Benefits of a Schema \u0026amp; Type System Setting up GraphQL Accessing the API  Registering User to Database Login API   Docker Users Commiting our changes Conclusion Support  Did you find this page helpful? Consider sharing it üôå     About this Article In this article you will learn the following things:-\n  About GraphQL and why to use it\n  Setup GraphQL\n  Register User to Database\n  Login User and get token using JWT\n  Write tests for the above setup\n  GraphQL is the better REST Over the past decade, REST has become the standard (yet a fuzzy one) for designing web APIs. It offers some great ideas, such as stateless servers and structured access to resources. However, REST APIs have shown to be too inflexible to keep up with the rapidly changing requirements of the clients that access them.\nGraphQL was developed to cope with the need for more flexibility and efficiency! It solves many of the shortcomings and inefficiencies that developers experience when interacting with REST APIs.\nTo illustrate the major differences between REST and GraphQL when it comes to fetching data from an API, let‚Äôs consider a simple example scenario: In a blogging application, an app needs to display the titles of the posts of a specific user. The same screen also displays the names of the last 3 followers of that user. How would that situation be solved with REST and GraphQL?\nData Fetching with REST vs GraphQL With a REST API, you would typically gather the data by accessing multiple endpoints. In the example, these could be /users/\u0026lt;id\u0026gt; endpoint to fetch the initial user data. Secondly, there‚Äôs likely to be a /users/\u0026lt;id\u0026gt;/posts endpoint that returns all the posts for a user. The third endpoint will then be the /users/\u0026lt;id\u0026gt;/followers that returns a list of followers per user.\n Image taken from other source\n In GraphQL on the other hand, you‚Äôd simply send a single query to the GraphQL server that includes the concrete data requirements. The server then responds with a JSON object where these requirements are fulfilled.\n Image taken from other source\n No more Over and Underfetching One of the most common problems with REST is that of over- and underfetching. This happens because the only way for a client to download data is by hitting endpoints that return fixed data structures. It‚Äôs very difficult to design the API in a way that it‚Äôs able to provide clients with their exact data needs.\n ‚ÄúThink in graphs, not endpoints.‚Äù Lessons From 4 Years of GraphQL by Lee Byron, GraphQL Co-Inventor.\n Overfetching: Downloading superfluous data Overfetching means that a client downloads more information than is actually required in the app. Imagine for example a screen that needs to display a list of users only with their names. In a REST API, this app would usually hit the /users endpoint and receive a JSON array with user data. This response however might contain more info about the users that are returned, e.g. their birthdays or addresses - information that is useless for the client because it only needs to display the users‚Äô names.\nUnderfetching and the n+1 problem Another issue is underfetching and the n+1 requests problem. Underfetching generally means that a specific endpoint doesn‚Äôt provide enough of the required information. The client will have to make additional requests to fetch everything it needs. This can escalate to a situation where a client needs to first download a list of elements, but then needs to make one additional request per element to fetch the required data.\nAs an example, consider the same app would also need to display the last three followers per user. The API provides the additional endpoint /users/\u0026lt;user-id\u0026gt;/followers. In order to be able to display the required information, the app will have to make one request to the /users endpoint and then hit the /users/\u0026lt;user-id\u0026gt;/followers endpoint for each user.\nBenefits of a Schema \u0026amp; Type System GraphQL uses a strong type system to define the capabilities of an API. All the types that are exposed in an API are written down in a schema using the GraphQL Schema Definition Language (SDL). This schema serves as the contract between the client and the server to define how a client can access the data.\nOnce the schema is defined, the teams working on frontend and backends can do their work without further communication since they both are aware of the definite structure of the data that‚Äôs sent over the network.\nFrontend teams can easily test their applications by mocking the required data structures. Once the server is ready, the switch can be flipped for the client apps to load the data from the actual API.\nSetting up GraphQL I hope I taught you little bit about graphQL, to know more you can check out here. GraphQL is a query language for your API, and a server-side runtime for executing queries by using a type system you define for your data. GraphQL isn‚Äôt tied to any specific database or storage engine and is instead backed by your existing code and data. A GraphQL service is created by defining types and fields on those types, then providing functions for each field on each type. We will be using express-graphql for our application. So run this command in your terminal\nnpm i --quiet graphql express-graphql --save\nNon npm users just copy this to package.json\n\u0026quot;express-graphql\u0026quot;: \u0026quot;^0.7.1\u0026quot;, \u0026quot;graphql\u0026quot;: \u0026quot;^14.0.2\u0026quot;,  We will require our installed module and use this, so now copy this to your src/app.ts\nconst graphqlHTTP = require(\u0026quot;express-graphql\u0026quot;); import { schema } from \u0026quot;./schemas\u0026quot;;  Also change our member function private this.initAppRoutes() {} in src/app.ts to the code given below.\nprivate initAppRoutes() { this.app.use(\u0026quot;/graphql\u0026quot;, graphqlHTTP({ schema, graphiql: true, })); }  You will encounter some error, so lets work and solve them. Firstly, we need to create a schemas folder inside src. Then create a 5 files inside it\n  userSchema.ts\n  graphql.ts\n  userLoginSchema.ts\n  userRegisterSchema.ts\n  index.ts\n  Inside src/schemas/userSchema.ts copy this\nimport bcrypt = require(\u0026quot;bcrypt-nodejs\u0026quot;); import { Schema } from \u0026quot;mongoose\u0026quot;; import mongoose = require(\u0026quot;mongoose\u0026quot;); mongoose.Promise = global.Promise; /** * This is Schema for User * @constant {UserSchema} */ export const UserSchema = new Schema({ id: { type: String, }, username: { type: String, trim: true, unique: true, select: true, }, name: { type: String, select: true, required: true, }, password: { type: String, select: false, }, }, { timestamps: {}, }); UserSchema.methods.generateHash = function(password): boolean { return bcrypt.hashSync(password, bcrypt.genSaltSync(8), null); }; UserSchema.methods.validPassword = function(password): boolean { return bcrypt.compareSync(password, this.password); };  Explanation:-\n  This file defines mongoose schema for our database.\n  Line 1‚Äì3:- Requiring necessary module.\n  Line 11‚Äì32:- We are exporting our schema on line 11. On the same line we create a new Schema with properties specified below. Lets expain username property. username will be of type String and it will be unique. What select property does that is when we call this schema it will show the property of user which have select as true. You may notice we have specified select: false for password on line 28. It means we won‚Äôt be getting password by default for any queries we execute for user.\n  Line 34‚Äì40:- We defined 2 methods for users to generate a hashed password and validate that password.\n  Inside src/schemas/graphql.ts copy this\nimport { GraphQLNonNull, GraphQLObjectType, GraphQLSchema } from \u0026quot;graphql\u0026quot;; import { login, register } from \u0026quot;../routes\u0026quot;; import { userLoginSchema } from \u0026quot;./userLoginSchema\u0026quot;; import { userRegisterSchema } from \u0026quot;./userRegisterSchema\u0026quot;; // Define the Query type const queryType = new GraphQLObjectType({ name: \u0026quot;Query\u0026quot;, fields: { loginUser: { type: new GraphQLNonNull(userRegisterSchema.responseType), // `args` describes the arguments that the `user` query accepts args: { input: { type: userLoginSchema.UserInput }, }, async resolve(_, args) { const val = await login(args); return val; }, }, }, }); // Defining Mutation const mutationType = new GraphQLObjectType({ name: \u0026quot;Mutation\u0026quot;, fields: { registerUser: { type: new GraphQLNonNull(userRegisterSchema.responseType), // `args` describes the arguments that the `user` query accepts args: { input: { type: userRegisterSchema.UserInput }, }, async resolve(_, args) { const val = await register(args); return val; }, }, }, }); export const schema = new GraphQLSchema({ query: queryType, mutation: mutationType, });  Explanation:-\n  In this file we are defining our schema for graphQL here.\n  Line 7‚Äì22:- We define querytype as type query. In this we will be defining all our queries. fileds property tell all queries we can use. Line 10‚Äì15 will be like this for example.\n  query loginUser($input userInputLogin) { loginUser(input: $input){} where $input is { input { username: \u0026quot;anything\u0026quot;, password: \u0026quot;anything, }  . After this when query is written and input is provided line 16 will execute and it will asynchronously execute resolve function which is provided 2 arguments. args contains the input that we provided. After we wait for our login result as login returns a promise. We return the value on line 18. Similarly line 25‚Äì40 work but it is of type mutation, it is somewhat like POST request.\nInside src/schemas/userLoginSchema.ts copy this\nimport { GraphQLInputObjectType, GraphQLString } from \u0026quot;graphql\u0026quot;; // User input is getting input from user const UserInput = new GraphQLInputObjectType({ name: \u0026quot;UserInputLogin\u0026quot;, fields: { username: { type: GraphQLString }, password: { type: GraphQLString }, }, }); export const userLoginSchema = { UserInput, };  Explanation:-\n In this file we define the login Schema. It will be the return type of our input that we are providing.  Inside src/schemas/userRegisterSchema.ts copy this\nimport { GraphQLBoolean, GraphQLID, GraphQLInputObjectType, GraphQLInt, GraphQLNonNull, GraphQLObjectType, GraphQLString } from \u0026quot;graphql\u0026quot;; // User type const userType = new GraphQLObjectType({ name: \u0026quot;User\u0026quot;, fields: { id: { type: GraphQLID }, username: { type: GraphQLString }, name: { type: GraphQLString }, password: { type: GraphQLString }, token: { type: GraphQLString }, createdAt: { type: GraphQLString }, updatedAt: { type: GraphQLString }, }, }); // Data reponse of user const DataResponse = new GraphQLObjectType({ name: \u0026quot;DataResponse\u0026quot;, fields: { success: { type: GraphQLBoolean }, user: { type: userType }, token: { type: GraphQLString }, }, }); // Response from User const responseType = new GraphQLObjectType({ name: \u0026quot;Response\u0026quot;, fields: { code: { type: new GraphQLNonNull(GraphQLInt) }, message: { type: new GraphQLNonNull(GraphQLString) }, data: { type: new GraphQLNonNull(DataResponse) }, }, }); // User input is getting input from user const UserInput = new GraphQLInputObjectType({ name: \u0026quot;UserInputRegister\u0026quot;, fields: { username: { type: GraphQLString }, name: { type: GraphQLString }, password: { type: GraphQLString }, }, }); export const userRegisterSchema = { userType, DataResponse, responseType, UserInput, };  Explanation:-\n In this file we define the register Schema. It will be the return type of our input that we are providing.  And finally copy this to src/schemas/index.ts\nexport * from \u0026quot;./userSchema\u0026quot;; export * from \u0026quot;./graphql\u0026quot;; export * from \u0026quot;./userRegisterSchema\u0026quot;; export * from \u0026quot;./userLoginSchema\u0026quot;;  You will be getting error Cannot find module '../routes'. Don‚Äôt worry we will fix it later. Let‚Äôs first create some important things. Create a folder models and 2 files inside it\n  response.ts\n  index.ts\n  Copy this inside src/models/response.ts\nexport class Response { public code: number; public message: string; public data: any; constructor(code: number, message: string, data: any) { this.code = code; this.message = message; this.data = data; } }  Copy this inside src/models/index.ts :\nexport * from \u0026quot;./response\u0026quot;;  To modulerize our code we will create another folder functions and a file inside it\n complete.ts  Copy this inside src/functions/complete.ts :\nimport { Response } from \u0026quot;../models\u0026quot;; export function completeRequest(promise: Promise\u0026lt;Response\u0026gt;): any { const res = promise.then((response) =\u0026gt; { const finallResponse = { code: response.code, message: response.message, data: response.data, }; return finallResponse; }).catch((errorRes) =\u0026gt; { const finallResponse = { code: errorRes.code, message: errorRes.message, data: errorRes.data, }; return finallResponse; }); return res; }  This file returns a promise that contains final response of data. We resolve this promise in our graphql.ts file.\nBefore solving our routes folder issue we will first create a folder called interface and then create 2 files inside it, given below:-\n  userInterface.ts\n  index.ts\n  One of TypeScript‚Äôs core principles is that type-checking focuses on the shape that values have. This is sometimes called ‚Äúduck typing‚Äù or ‚Äústructural subtyping‚Äù. In TypeScript, interfaces fill the role of naming these types, and are a powerful way of defining contracts within your code as well as contracts with code outside of your project.\ncopy this inside src/interfaces/userInteface.ts :\nimport {Document} from \u0026quot;mongoose\u0026quot;; /** * This is interface for user * @interface * @extends {Document} */ export interface IUser extends Document { // tslint:disable-next-line:semicolon username: string, // tslint:disable-next-line:semicolon password: string, // tslint:disable-next-line:semicolon _id: any, // tslint:disable-next-line:semicolon name: string, }  And copy this inside src/interfaces/index.ts\nexport * from \u0026quot;./userInterface\u0026quot;;  Now everthing is complete. Its time to create routes folder. Create 2 files inside it\n  user.ts\n  index.ts\n  And copy this inside src/routes/user.ts\nimport jwt = require(\u0026quot;jsonwebtoken\u0026quot;); import { model } from \u0026quot;mongoose\u0026quot;; import { completeRequest } from \u0026quot;../functions/complete\u0026quot;; import { IUser } from \u0026quot;../interfaces\u0026quot;; import { Response } from \u0026quot;../models\u0026quot;; import { UserSchema } from \u0026quot;../schemas\u0026quot;; import { Config } from \u0026quot;../shared\u0026quot;; const User = model(\u0026quot;User\u0026quot;, UserSchema); /** * This is route for registering user in database * @param args */ export async function register(args) { const promise: Promise\u0026lt;Response\u0026gt; = new Promise\u0026lt;Response\u0026gt;((resolve, reject) =\u0026gt; { const secret: any = Config.secretKeys.jwtSecret; // getting data from args const username = String(args.input.username).trim(); if (!username || !args.input.username || !args.input.name) { reject(new Response(200, \u0026quot;Please fill both username and name\u0026quot;, { success: false, })); } else if (username.length \u0026lt; 4 || args.input.name.trim().length \u0026lt; 4) { reject(new Response(200, \u0026quot;Username and name should be contain atleast 4 characters\u0026quot;, { success: false, })); } else { const name = args.input.name.trim(); User.findOne({ username }).then((user: any) =\u0026gt; { if (user !== null) { reject(new Response(200, \u0026quot;username already in use\u0026quot;, { success: false, })); } else { const newUser: any = new User({ username, name, }); newUser.id = newUser._id; // generating new hashed password newUser.password = newUser.generateHash(args.input.password); newUser.save().then((user: IUser) =\u0026gt; { const token = jwt.sign({ id: user._id }, secret, { expiresIn: \u0026quot;23h\u0026quot;, }); resolve(new Response(200, \u0026quot;Successful response\u0026quot;, { success: true, user, token, })); }); } }); } }); const val = await completeRequest(promise); return val; } export async function login(args) { const promise: Promise\u0026lt;Response\u0026gt; = new Promise\u0026lt;Response\u0026gt;((resolve, reject) =\u0026gt; { if (!args.input.username || !args.input.password) { reject(new Response(200, \u0026quot;Please enter both field username and password\u0026quot;, { success: false, })); } // Getting data from req.body const username = args.input.username; const secret: any = Config.secretKeys.jwtSecret; // Searching for User in database User.findOne({ username }).select(\u0026quot;password id createdAt updatedAt\u0026quot;).then((user: any) =\u0026gt; { if (!user) { reject(new Response(200, \u0026quot;Sorry, No user found\u0026quot;, { success: false, })); } else { if (!user.validPassword(args.input.password)) { reject(new Response(200, \u0026quot;Incorrect Password\u0026quot;, { success: false, })); } else { const token = jwt.sign({ id: user._id }, secret, { expiresIn: \u0026quot;23h\u0026quot;, }); resolve(new Response(200, \u0026quot;Successful response\u0026quot;, { success: true, user, token, })); } } }); }); const val = await completeRequest(promise); return val; }  Explanation:-\n  Line 1‚Äì7:- We require necessary modules.\n  Line 9:- We create a model for our userSchema.\n  Line 16:- We export our function to register user to database. This function is returning a promise. The parameter args contains input from user.\n  Line 22‚Äì29:- We write tests for wrong input from user and reject our promise with our Response class that we created in response.ts.\n  Line 32‚Äì37:- If everything from user side looks fine, we check whether the username entered by user is already in database or not. If yes we reject with another new response.\n  Line 38‚Äì41:- We create a new User.\n  Lin 45:- We hash the password using the method we created in userSchema.ts.\n  Line 52‚Äì57:- If everything is fine, we resolve our promise and send the required info.\n  Line 62‚Äì63:- Our function completeRequest defined in functions folder, takes a promise and resolves it and send back another promise with some our required data. Then we use use await to wait for our data, until it is returned to us and stored inside val. Then we return val.\n  Similary like this we are working with login function starting from line 66.\n  Before running our code, lets create our tests for the code we have written so far. Create 2 files inside src/test\n  registerUserQueries.ts\n  loginUserQueries.ts\n  Copy this inside src/test/registerUserQueries.ts\nconst query = `mutation registerUser($input: UserInputRegister) { registerUser(input: $input) { code message data { token success user { id createdAt username name password updatedAt } } } } `; const registerSuccessfullyQuery = { query: query, operationName: \u0026quot;registerUser\u0026quot; , variables: { input: { username: \u0026quot;knrt10\u0026quot;, name: \u0026quot;Kautilya\u0026quot;, password: \u0026quot;test\u0026quot;, }, }, }; const registerSuccessfullyQuerySecondUser = { query: query, operationName: \u0026quot;registerUser\u0026quot; , variables: { input: { username: \u0026quot;knrt191\u0026quot;, name: \u0026quot;Second\u0026quot;, password: \u0026quot;test\u0026quot;, }, }, }; const registerSuccessfullyQueryThirdUser = { query: query, operationName: \u0026quot;registerUser\u0026quot; , variables: { input: { username: \u0026quot;knrt1912\u0026quot;, name: \u0026quot;Third\u0026quot;, password: \u0026quot;test\u0026quot;, }, }, }; const registerFailNoUsernameQuery = { query: query , operationName: \u0026quot;registerUser\u0026quot; , variables: { input: { username: \u0026quot;\u0026quot;, name: \u0026quot;Kautilya\u0026quot;, password: \u0026quot;test\u0026quot;, }, }, }; const registerFailSmallUsernameQuery = { query: query, operationName: \u0026quot;registerUser\u0026quot; , variables: { input: { username: \u0026quot;d \u0026quot;, name: \u0026quot;Kautilya\u0026quot;, password: \u0026quot;test\u0026quot;, }, }, }; export const registerqueries = { registerSuccessfullyQuery, registerSuccessfullyQuerySecondUser, registerSuccessfullyQueryThirdUser, registerFailNoUsernameQuery, registerFailSmallUsernameQuery, };  Explanation:- In this file we are creating a demo possible queries for register API which user can pass. We use this in our tests.\n  Line 1‚Äì19:- It contains our query that we will use later to register user, but in our tests we need our code to automatically create user, so we use this method.\n  Line 21‚Äì32:- We are defining a constant that is just an example of data we will be sending to our test route. It is using query that we defined on line 1. The operation name will be registerUser. Also we are passing variables to our query declared on line 25.\n  Rest file contains same type of different cases that a user can enter. We will test those all cases in our tests.\n  In the end we are exporting all the constants that we declared in this file, so that they can be used in other files.\n  And copy this inside src/test/loginUserQueries.ts\nconst query = `query loginUser($input: UserInputLogin) { loginUser(input: $input) { code, message, data { success user { id name username password } token } } }`; const loginSuccessfullyQuery = { query: query, operationName: \u0026quot;loginUser\u0026quot; , variables: { input: { username: \u0026quot;knrt10\u0026quot;, password: \u0026quot;test\u0026quot;, }, }, }; const loginFailWrongPasswordQuery = { query: query, operationName: \u0026quot;loginUser\u0026quot; , variables: { input: { username: \u0026quot;knrt10\u0026quot;, password: \u0026quot;test1\u0026quot;, }, }, }; const loginFailNopassWordorUsernameQuery = { query: query, operationName: \u0026quot;loginUser\u0026quot; , variables: { input: { username: \u0026quot;\u0026quot;, password: \u0026quot;\u0026quot;, }, }, }; const loginFailwrongUsernamQuery = { query: query, operationName: \u0026quot;loginUser\u0026quot; , variables: { input: { username: \u0026quot; bla \u0026quot;, password: \u0026quot;shit this is bro\u0026quot;, }, }, }; export const loginQueries = { loginSuccessfullyQuery, loginFailWrongPasswordQuery, loginFailNopassWordorUsernameQuery, loginFailwrongUsernamQuery, };  Explanation:- In this file we are creating a demo possible queries for login API which user can pass. We use this in our tests.\n  Just like registerQueries, this file has a query declared on line 1, which we will use in our test.\n  Cases that user can enter are declared in rest of file and then finally exported to be used later on in our test file.\n  Now you need to make changes to your src/test/user-test.spec.ts Update your whole file to this.\nimport chai = require(\u0026quot;chai\u0026quot;); import chaiAsPromised = require(\u0026quot;chai-as-promised\u0026quot;); import chaiHttp = require(\u0026quot;chai-http\u0026quot;); import { suite, test } from \u0026quot;mocha-typescript\u0026quot;; import { model } from \u0026quot;mongoose\u0026quot;; import sinon = require(\u0026quot;sinon\u0026quot;); import { Response } from \u0026quot;../models\u0026quot;; import { UserSchema } from \u0026quot;../schemas\u0026quot;; import { TodoApp } from \u0026quot;../server\u0026quot;; import { Config } from \u0026quot;../shared\u0026quot;; import { loginQueries } from \u0026quot;./loginUserQueries\u0026quot;; import { registerqueries } from \u0026quot;./registerUserQueries\u0026quot;; const User = model(\u0026quot;User\u0026quot;, UserSchema); // starting the server const server: TodoApp = new TodoApp(process.env.API_PORT || 3001); server.startServer(); chai.use(chaiAsPromised); chai.use(chaiHttp); @suite(\u0026quot;User Test class\u0026quot;) class UserTests { static user: any; static before() { this.testData = { input: { username: \u0026quot;knrt10\u0026quot;, name: \u0026quot;Kautilya\u0026quot;, password: \u0026quot;test\u0026quot;, }, }; } static after() { // Delete User Created So that it does not provide error in next test User.findOneAndDelete({ username: UserTests.testData.input.username }, () =\u0026gt; { process.exit(0); }); } private static testData: any; private static token: string; @test(\u0026quot;Testing Local Connection - try connection for Local mongodb\u0026quot;) public localDb(done) { setTimeout(() =\u0026gt; { Config.dbSettings.localDatabase = true; const mock = sinon.mock(new TodoApp(process.env.API_PORT || 3001), \u0026quot;constructor\u0026quot;); chai.expect(mock.object.infoString).to.deep.equal(\u0026quot;mongodb://\u0026quot; + Config.dbSettings.connectionString + \u0026quot;/\u0026quot; + Config.dbSettings.database); done(); }, 100); } @test(\u0026quot;Testing Docker Connection - try connection for docker mongodb\u0026quot;) public dockerDb(done) { Config.dbSettings.localDatabase = false; const mock = sinon.mock(new TodoApp(process.env.API_PORT || 3001), \u0026quot;constructor\u0026quot;); chai.expect(mock.object.infoString).to.deep.equal(\u0026quot;mongodb://\u0026quot; + Config.dbSettings.dockerconnectionString + \u0026quot;/\u0026quot; + Config.dbSettings.database); done(); } @test(\u0026quot;Testing Online Connection - try connection for online mongodb\u0026quot;) public OnlineDb(done) { Config.dbSettings.authEnabled = true; const mock = sinon.mock(new TodoApp(process.env.API_PORT || 3001), \u0026quot;constructor\u0026quot;); chai.expect(mock.object.infoString).to.deep.equal(\u0026quot;mongodb://\u0026quot; + Config.dbSettings.username + \u0026quot;:\u0026quot; + Config.dbSettings.password + \u0026quot;@\u0026quot; + Config.dbSettings.connectionString + \u0026quot;/\u0026quot; + Config.dbSettings.database); done(); } @test(\u0026quot;POST Register - try Register User Successfuly\u0026quot;) public createUser(done) { chai.request(\u0026quot;http://localhost:\u0026quot; + server.port) .post(\u0026quot;/graphql\u0026quot;) .send(registerqueries.registerSuccessfullyQuery) .end((err, res) =\u0026gt; { chai.expect(res).to.have.status(200); chai.expect(res.body.data.registerUser).to.deep.equal(new Response(200, \u0026quot;Successful response\u0026quot;, { success: true, user: res.body.data.registerUser.data.user, token: res.body.data.registerUser.data.token, })); done(); }); } @test(\u0026quot;POST Register - Don't register as user already registered\u0026quot;) public dontRegisterUser(done) { chai.request(\u0026quot;http://localhost:\u0026quot; + server.port) .post(\u0026quot;/graphql\u0026quot;) .send(registerqueries.registerSuccessfullyQuery) .end((err, res) =\u0026gt; { chai.expect(res).to.have.status(200); chai.expect(res.body.data.registerUser).to.deep.equal(new Response(200, \u0026quot;username already in use\u0026quot;, { success: false, token: null, user: null, })); done(); }); } @test(\u0026quot;POST Register - try No username field\u0026quot;) public dontCreateUser(done) { chai.request(\u0026quot;http://localhost:\u0026quot; + server.port) .post(\u0026quot;/graphql\u0026quot;) .send(registerqueries.registerFailNoUsernameQuery) .end((err, res) =\u0026gt; { chai.expect(res).to.have.status(200); chai.expect(res.body.data.registerUser).to.deep.equal(new Response(200, \u0026quot;Please fill both username and name\u0026quot;, { success: false, token: null, user: null, })); done(); }); } @test(\u0026quot;POST Register - try username of small length\u0026quot;) public dontCreateUserLessLength(done) { chai.request(\u0026quot;http://localhost:\u0026quot; + server.port) .post(\u0026quot;/graphql\u0026quot;) .send(registerqueries.registerFailSmallUsernameQuery) .end((err, res) =\u0026gt; { chai.expect(res).to.have.status(200); chai.expect(res.body.data.registerUser).to.deep.equal(new Response(200, \u0026quot;Username and name should be contain atleast 4 characters\u0026quot;, { success: false, token: null, user: null, })); done(); }); } @test(\u0026quot;POST Login - try Successful Login\u0026quot;) public login(done) { chai.request(\u0026quot;http://localhost:\u0026quot; + server.port) .post(\u0026quot;/graphql\u0026quot;) .send(loginQueries.loginSuccessfullyQuery) .end((err, res) =\u0026gt; { UserTests.user = res.body.data.loginUser.data.user; UserTests.token = res.body.data.loginUser.data.token; chai.expect(res).to.have.status(200); chai.expect(res.body.data.loginUser).to.deep.equal(new Response(200, \u0026quot;Successful response\u0026quot;, { success: true, user: res.body.data.loginUser.data.user, token: res.body.data.loginUser.data.token, })); done(); }); } @test(\u0026quot;POST Login - try hit the login with incorrect credentials route\u0026quot;) public loginWithIncorrect(done) { chai.request(\u0026quot;http://localhost:\u0026quot; + server.port) .post(\u0026quot;/graphql\u0026quot;) .send(loginQueries.loginFailWrongPasswordQuery) .end((err, res) =\u0026gt; { chai.expect(res).to.have.status(200); chai.expect(res.body.data.loginUser).to.deep.equal(new Response(200, \u0026quot;Incorrect Password\u0026quot;, { success: false, user: null, token: null, })); done(); }); } @test(\u0026quot;POST Login - try hit the login no password\u0026quot;) public wrongInputFields(done) { chai.request(\u0026quot;http://localhost:\u0026quot; + server.port) .post(\u0026quot;/graphql\u0026quot;) .send(loginQueries.loginFailNopassWordorUsernameQuery) .end((err, res) =\u0026gt; { chai.expect(res).to.have.status(200); chai.expect(res.body.data.loginUser).to.deep.equal(new Response(200, \u0026quot;Please enter both field username and password\u0026quot;, { success: false, user: null, token: null, })); done(); }); } @test(\u0026quot;POST Login - try Posting wrong username\u0026quot;) public NoUser(done) { chai.request(\u0026quot;http://localhost:\u0026quot; + server.port) .post(\u0026quot;/graphql\u0026quot;) .send(loginQueries.loginFailwrongUsernamQuery) .end((err, res) =\u0026gt; { chai.expect(res).to.have.status(200); chai.expect(res.body.data.loginUser).to.deep.equal(new Response(200, \u0026quot;Sorry, No user found\u0026quot;, { success: false, user: null, token: null, })); done(); }); } }  Explanation:-\n  Line 1‚Äì12:- We require all the necessary files and modules.\n  Line 14:- We create a user model for our tests.\n  Line 16‚Äì17:- We start the server of our express application.\n  Line 26‚Äì34:- before is a method on chai that executes before our tests start running. So anything declared inside it will execute first.\n  Line 36‚Äì41:- Similarly like before method, after method is a predefined method in chai. It will be executed after all the tests have run. It does not depend your tests pass or fail. In Our tests are running inside a class, so we need to declare these methods as static which means that it doesn‚Äôt have to be instantiated. In this method we are deleting user that we will create in our tests, so that next that we run our test that user is not already present in our database.\n  Line 73‚Äì87:- This tests is checking whether user gets successfully registered to database. We create a post request with data we created in our registerUserQueries.ts. And then this code send data to our code written in user.ts and if returns a response. Then we check assertion wheter the response matches with the required response in our test.\n  Just like this we create different test cases for all possible situation. Just read the message inside @test(\u0026quot;\u0026quot;), you will understand what test case it is about.\nRemember before running tests your mongoDb server is up and running then when you run npm run build \u0026amp;\u0026amp; npm run coverage you get\n Project setup and tests until now with üíØ code coverage\n Accessing the API First check your mongoDB server is up and running. Then start your server by running the following command\nnpm start\nTo access the API of application open your GraphQL-Playground and enter url http://localhost:3000/graphql\nRegistering User to Database Enter Query\nmutation registerUser($input: UserInputRegister) { registerUser(input: $input) { code message data { token success user { id createdAt username name password updatedAt } } } }  and then query variable\n{ \u0026quot;input\u0026quot;: { \u0026quot;username\u0026quot;: \u0026quot;knrt10\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;Kautilya\u0026quot;, \u0026quot;password\u0026quot;: \u0026quot;test\u0026quot; } }  Then hit play button, you will get response like this\n registering user to Database\n Login API Enter Query\nquery loginUser($input: UserInputLogin) { loginUser(input: $input) { code, message, data { success user { id name username password } token } } }  and then query variable\n{ \u0026quot;input\u0026quot;: { \u0026quot;username\u0026quot;: \u0026quot;knrt10\u0026quot;, \u0026quot;password\u0026quot;: \u0026quot;test\u0026quot; } }  Then after you hit play button you will see this output.\n login response\n Try playing with it and try to enter wrong data or anything like that. You might find we have covered error for most of the usual cases.\n playing with GraphQL Playground üìπ\n Docker Users You need to make all the code changes as above and then just run\nnpm run dockerStart\nAfter that you can also excess API of application as above with same URL http://localhost:3000/graphql.\nThen after using don‚Äôt forget to stop the container by runnnig npm run dockerStop.\nCommiting our changes Lets commit our new changes for this part. Copy and run the commands given below inside your git repository. Make sure you are in root folder.\ngit add . git commit -m \u0026quot;Adding part2 changes\u0026quot;  Conclusion That is for this part. In this part you learnt following things:-\n  Modularize code.\n  How to create Mongoose Schema.\n  Why GraphQL is better than REST.\n  How to setup GraphQL in node.\n  How to write Schema for GraphQL.\n  How and write tests and maintain üíØ code coverage üòâ.\n  In next part you will create schemas for working with CRUD operation on a Todo, only when you are authenticated.\n  Support I wrote this series of articles by using my free time. A little motivation and support helps me a lot. If you like this nifty hack you can support me by doing any (or all üòâ ) of the following:\n  Follow me on Github for more such projects.\n  ‚≠êÔ∏è Star it on Github and make it trend so that other people can know about my project.\n  Did you find this page helpful? Consider sharing it üôå ","date":1546128000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1608895031,"objectID":"42fbe150cc9a38ff0fe07171a0ba29d3","permalink":"/post/part-2-api-using-graphql/","publishdate":"2018-12-30T00:00:00Z","relpermalink":"/post/part-2-api-using-graphql/","section":"post","summary":"This is a series of 3 articles which will help to write production grade code.","tags":["js","opensource","node.js","docker","mongodb","testing","grpahql"],"title":"Part 2:- API using GraphQL and Node.js","type":"post"},{"authors":["Kautilya Tripathi"],"categories":["opensource"],"content":"This article is for people who are interested in learning to write optimized code using GraphQL with unit testing using mocha and chai.\nBefore we start, we need to define the functionality of our API. The application will be a simple todo app. It will create a user in a database who will be able to create, get and delete todos. If you don‚Äôt understand the code or get stuck somewhere, you can check out the code from my Github repository.\nTable of Contents  About the series What you will learn? In this Article Requirements Project Setup Docker Setup  Exploring container from within   Setting up Express server Commiting our changes Conclusion  Did you find this page helpful? Consider sharing it üôå     About the series This is a series of 3 articles which will help to write production grade code. I wanted to help others who might have faced same problems as me. This article can help a beginner and also to someone who has good knowledge in node.\nWhat you will learn?  TypeScript (if you don‚Äôt write it already). Using Docker for Node projects. Writing a GraphQL API instead of REST. Basics of MongoDB. Logging. Working with JWT(Json Web token). Writing tests and working with code coverage. Writing clean code and linting. Writing modular code. Basics of Promises, async and await. Writing production grade code.  In this Article In this article you will be able to do the following things:-\n Setup project Setup docker Write express server and connect to mongodb Write tests for above setup.  Requirements   Node and npm installed for your OS. We will use node environment to work on this project.\n  Docker installed for your OS. Along with local working of project, you will learn little bit of docker and how to work on projects if you don‚Äôt have node and npm installed.\n  GraphQL-Playground for testing your API. This is an awesome tool where you will test your APIs and learn how to use this tool.\n  Important :- I will teach how to work with project locally and also how to work with Docker side by side. Those who want to work only with docker, I will refer to them as non npm users. Also we will try to follow TDD(test driven Development) approach.\n  Project Setup Open your development folder and create a new Folder for our project and go to it or copy the following command.\nmkdir graphql-todo\nNow open your code editor inside that folder.\nIf you have npm installed for your OS run\nnpm init -y. It will create a package.json file like this\n{ \u0026quot;name\u0026quot;: \u0026quot;graphql-todo\u0026quot;, \u0026quot;version\u0026quot;: \u0026quot;1.0.0\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;main\u0026quot;: \u0026quot;index.js\u0026quot;, \u0026quot;scripts\u0026quot;: { \u0026quot;test\u0026quot;: \u0026quot;echo \\\u0026quot;Error: no test specified\\\u0026quot; \u0026amp;\u0026amp; exit 1\u0026quot; }, \u0026quot;keywords\u0026quot;: [], \u0026quot;author\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;license\u0026quot;: \u0026quot;ISC\u0026quot; }  non npm users just create a package.json file and copy the above contents. You can edit description to anything you like.\nWe will be writing code in Typescript so we will need something that will compile our code fast and minify the process. So for this we will use Gulp. Run the given command below in your terminal inside the project.\nnpm i --quiet gulp gulp-sourcemaps gulp-typescript typescript --save-dev non npm users copy this to your package.json file.\n\u0026quot;devDependencies\u0026quot;: { \u0026quot;gulp\u0026quot;: \u0026quot;^4.0.0\u0026quot;, \u0026quot;gulp-sourcemaps\u0026quot;: \u0026quot;^2.6.4\u0026quot;, \u0026quot;gulp-typescript\u0026quot;: \u0026quot;^5.0.0\u0026quot;, \u0026quot;typescript\u0026quot;: \u0026quot;^3.2.2\u0026quot; }  Now you have gulp and typescript installed. We will now create a gulpfile and write our code to minify the process of building the project. Follow the step below.\nCreate a gulpfile.js inside root directory and copy this code.\nconst gulp = require(\u0026quot;gulp\u0026quot;); const ts = require(\u0026quot;gulp-typescript\u0026quot;); const sourcemaps = require(\u0026quot;gulp-sourcemaps\u0026quot;); const tsProject = ts.createProject(\u0026quot;tsconfig.json\u0026quot;, { typescript: require(\u0026quot;typescript\u0026quot;) }); gulp.task(\u0026quot;build\u0026quot;, () =\u0026gt; { gulp.src(\u0026quot;process.yml\u0026quot;) .pipe(gulp.dest(\u0026quot;dist\u0026quot;)); return tsProject.src() .pipe(sourcemaps.init()) .pipe(tsProject()) .js .pipe(sourcemaps.write()) .pipe(gulp.dest(\u0026quot;dist\u0026quot;)); }); gulp.task(\u0026quot;watchTask\u0026quot;, function () { gulp.watch(\u0026quot;src/**/*.ts\u0026quot;, [\u0026quot;build\u0026quot;]); }); gulp.task(\u0026quot;default\u0026quot;, gulp.series(\u0026quot;build\u0026quot;)); gulp.task(\u0026quot;watch\u0026quot;, gulp.series(\u0026quot;build\u0026quot;, \u0026quot;watchTask\u0026quot;));  Explanation\n  Line 1‚Äì3:- We are requiring our modules.\n  Line 4: We are using API of gulp-typescript and creating our TS project using tsconfig.json file which we will create later.\n  Line 8:- We are using Gulp API task and creating a task name build.\n  Line 9‚Äì10:- We are using Gulp API src and taking process.yml file as source(we will create it later) and piping it to our destination folder **dist.**Here gulp.src creates a readble stream and with the help of node streams we pipe it to a writable stream created by gulp.dest.\n  Line 12‚Äì17:- We are copying our whole code as per tsconfig.json and converting it to Javascript and pasting it to dist folder.\n  Line 20‚Äì22:- We are creating another task watchTask for watching any changes in our build task.\n  Line 24‚Äì25:- We are finally using Gulp‚Äôs default API for runnig build task and watch API for watching changes to build and watch task.\n  Create a tsconfig.json file in root directory and copy this code.\n{ \u0026quot;compilerOptions\u0026quot;: { \u0026quot;emitDecoratorMetadata\u0026quot;: true, \u0026quot;experimentalDecorators\u0026quot;: true, \u0026quot;outDir\u0026quot;: \u0026quot;./dist\u0026quot;, \u0026quot;moduleResolution\u0026quot;: \u0026quot;node\u0026quot;, \u0026quot;baseUrl\u0026quot;: \u0026quot;./src\u0026quot;, \u0026quot;sourceMap\u0026quot;: true, \u0026quot;pretty\u0026quot;: true, \u0026quot;strictNullChecks\u0026quot;: true, \u0026quot;module\u0026quot;: \u0026quot;commonjs\u0026quot;, \u0026quot;target\u0026quot;: \u0026quot;es6\u0026quot;, \u0026quot;allowJs\u0026quot;: true }, \u0026quot;include\u0026quot;: [ \u0026quot;src/**/*.ts\u0026quot; ], \u0026quot;exclude\u0026quot;: [ \u0026quot;node_modules\u0026quot; ] }  Important:- Do notice baseUrl and outDir. baseUrl is where we will write our TS code and outDir is where gulp will compile and copy our code to JavaScript.\nNow create a process.yml file in root directory and copy this code.\napps: - script : 'app.js' name : 'Backend To-do Application' node_args : '--inspect=0.0.0.0:5858'  We will learn why we are creating this file later on. After this create an empty directory src in our root folder. Up until now you might have project config like this. Those who are going to work only with docker, they will not have package-lock.json and node_modules.\nProject setup until now\nTo keep track of our work we will be using git. If not installed you can go through git to install it.\nIn your project initialize your repository as git repository by git init.\nFor working in developement version we will need nodemon and ts-node for reloading our server automatically when any change is made in our file and executing our TS file without building them respectively. We will use TSlint as our code linter. In your terminal inside project directory run this command.\nnpm i --quiet nodemon ts-node tslint tslint-eslint-rules --save-dev\n\u0026quot;nodemon\u0026quot;: \u0026quot;^1.18.9\u0026quot;, \u0026quot;ts-node\u0026quot;: \u0026quot;^7.0.1\u0026quot;, \u0026quot;tslint\u0026quot;: \u0026quot;^5.12.0\u0026quot;, \u0026quot;tslint-eslint-rules\u0026quot;: \u0026quot;^5.4.0\u0026quot;,  Create a tslint.json file inside root directory and copy the code given below.\n{ \u0026quot;defaultSeverity\u0026quot;: \u0026quot;error\u0026quot;, \u0026quot;extends\u0026quot;: [ \u0026quot;tslint:recommended\u0026quot;, \u0026quot;tslint-eslint-rules\u0026quot; ], \u0026quot;jsRules\u0026quot;: {}, \u0026quot;rules\u0026quot;: { \u0026quot;object-literal-shorthand\u0026quot;: false, \u0026quot;object-literal-sort-keys\u0026quot;: [ false ], \u0026quot;ter-indent\u0026quot;: [ true, 2 ], \u0026quot;no-console\u0026quot;: false, \u0026quot;only-arrow-functions\u0026quot;: [ false ], \u0026quot;member-access\u0026quot;: false, \u0026quot;max-classes-per-file\u0026quot;: [ true, 5 ], \u0026quot;no-shadowed-variable\u0026quot;: false, \u0026quot;interface-name\u0026quot;: [ false ], \u0026quot;max-line-length\u0026quot;: [ true, 200 ], \u0026quot;no-var-requires\u0026quot;: false }, \u0026quot;rulesDirectory\u0026quot;: [] }  Inside scripts in package.json copy the following code.\n\u0026quot;dev\u0026quot;: \u0026quot;nodemon --no-deprecation --watch 'src/**/*.ts' --ignore 'src/**/*.spec.ts' --exec 'ts-node' src/app.ts\u0026quot;, \u0026quot;lint\u0026quot;: \u0026quot;tslint -c tslint.json 'src/**/*.ts' --fix\u0026quot;,  We will use npm run dev for running our code in development mode and npm run lint to lint our code. Now our actual coding will begin. Create a file inside src folder named as app.ts Copy this inside src/app.ts\nfunction testFunction(): string { return \u0026quot;Messi and Ronaldo are legends\u0026quot;; } export default testFunction;  Now we will test this. Create a test folder inside src, and then create a file user-test-spec.ts. For testing we will install required modules. We will be using mocha for testing and chai for assertion. Run this command inside your project.\nnpm i --quiet chai chai-http chai-as-promised mocha mocha-typescript sinon --save-dev\nnon npm users copy this inside devDependencies.\n\u0026quot;chai\u0026quot;: \u0026quot;^4.2.0\u0026quot;, \u0026quot;chai-as-promised\u0026quot;: \u0026quot;^7.1.1\u0026quot;, \u0026quot;chai-http\u0026quot;: \u0026quot;3.0.0\u0026quot;, \u0026quot;mocha\u0026quot;: \u0026quot;^5.2.0\u0026quot;, \u0026quot;mocha-typescript\u0026quot;: \u0026quot;^1.1.17\u0026quot;, \u0026quot;sinon\u0026quot;: \u0026quot;^7.2.2\u0026quot;,  We will create a script for testing. Copy this code inside scripts\n\u0026quot;test\u0026quot;: \u0026quot;mocha --no-deprecation --timeout 10000 --require ts-node/register **/*.spec.ts\u0026quot;  We can use this command using npm test . So far our package.json will look like this.\n{ \u0026quot;name\u0026quot;: \u0026quot;graphql-todo\u0026quot;, \u0026quot;version\u0026quot;: \u0026quot;1.0.0\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;This is a GraphQL API for todo application\u0026quot;, \u0026quot;main\u0026quot;: \u0026quot;index.js\u0026quot;, \u0026quot;scripts\u0026quot;: { \u0026quot;dev\u0026quot;: \u0026quot;nodemon --no-deprecation --watch 'src/**/*.ts' --ignore 'src/**/*.spec.ts' --exec 'ts-node' src/app.ts\u0026quot;, \u0026quot;lint\u0026quot;: \u0026quot;tslint -c tslint.json 'src/**/*.ts' --fix\u0026quot;, \u0026quot;start\u0026quot;: \u0026quot;gulp \u0026amp;\u0026amp; cd dist/ \u0026amp;\u0026amp; node --inspect=8990 --no-deprecation app.js\u0026quot;, \u0026quot;test\u0026quot;: \u0026quot;mocha --no-deprecation --timeout 10000 --require ts- node/register **/*.spec.ts\u0026quot; }, \u0026quot;keywords\u0026quot;: [], \u0026quot;author\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;license\u0026quot;: \u0026quot;ISC\u0026quot;, \u0026quot;devDependencies\u0026quot;: { \u0026quot;chai\u0026quot;: \u0026quot;^4.2.0\u0026quot;, \u0026quot;chai-as-promised\u0026quot;: \u0026quot;^7.1.1\u0026quot;, \u0026quot;chai-http\u0026quot;: \u0026quot;3.0.0\u0026quot;, \u0026quot;gulp\u0026quot;: \u0026quot;^4.0.0\u0026quot;, \u0026quot;gulp-sourcemaps\u0026quot;: \u0026quot;^2.6.4\u0026quot;, \u0026quot;gulp-typescript\u0026quot;: \u0026quot;^5.0.0\u0026quot;, \u0026quot;mocha\u0026quot;: \u0026quot;^5.2.0\u0026quot;, \u0026quot;mocha-typescript\u0026quot;: \u0026quot;^1.1.17\u0026quot;, \u0026quot;nodemon\u0026quot;: \u0026quot;^1.18.9\u0026quot;, \u0026quot;sinon\u0026quot;: \u0026quot;^7.2.2\u0026quot;, \u0026quot;ts-node\u0026quot;: \u0026quot;^7.0.1\u0026quot;, \u0026quot;tslint\u0026quot;: \u0026quot;^5.12.0\u0026quot;, \u0026quot;tslint-eslint-rules\u0026quot;: \u0026quot;^5.4.0\u0026quot;, \u0026quot;typescript\u0026quot;: \u0026quot;^3.2.2\u0026quot; } }  Inside your src/test/user-test.spec.ts copy this code\nimport chai = require(\u0026quot;chai\u0026quot;); import chaiAsPromised = require(\u0026quot;chai-as-promised\u0026quot;); import { suite, test } from \u0026quot;mocha-typescript\u0026quot;; import testFunction from \u0026quot;../app\u0026quot;; chai.use(chaiAsPromised); @suite(\u0026quot;User Test class\u0026quot;) class UserTests { @test(\u0026quot;testFunction Test - It works fine\u0026quot;) public testFunction(done) { chai.expect(testFunction()).to.deep.equal(\u0026quot;Messi and Ronaldo are legends\u0026quot;); done(); } }  Explanation:-\n  Line 1‚Äì4:- We are importing test modules and our file app.ts\n  Line 7‚Äì8:- We are defining suite to run and defining our class UserTests.\n  Line 10‚Äì16:- @test will declare the test message we are running, we also define a public test to run. We use chai.expect to test assetion of test.\n  Run your test by running npm test . If everything works fine, it will look like this.\nTo calculate test coverage of our code we will use nyc. We need to first check that our project is building or not. Copy this to scripts and then run npm run build\n\u0026quot;build\u0026quot;: \u0026quot;gulp\u0026quot;  You will get output as show below and a dist folder will be created.\nAdd nyc module by running npm i --quiet nyc --save-dev , non npm users copy this into package.json\n\u0026quot;nyc\u0026quot;: \u0026quot;^13.1.0\u0026quot;  Add the command given below to scripts.\n\u0026quot;coverage\u0026quot;: \u0026quot;nyc --reporter=text mocha --no-deprecation --timeout 10000 dist/test/*.spec.js -x dist/test/*.spec.js\u0026quot;,  We need to build to latest code first, then after that we will run code coverage by running npm run build \u0026amp;\u0026amp; npm run coverage. This will create a .nyc_output folder, from which our code coverage will be seen. You will see following output.\n Above image shows that we have achieved üíØ code coverage which depicts that we have not written any unusable code.\n Docker Setup Now we will setup docker so that non npm users can also run tests and build project without installing node or npm. I assume that the readers have a basic understanding of docker. If you have never used docker before you might wanna check out this guide for getting started with Docker.\nCreate a Dockerfile inside root directory and copy this\nFROM node:8 # Install gulp and pm2 globaly RUN npm install --quiet -g gulp pm2 # Create app directory RUN mkdir -p /usr/src/ WORKDIR /usr/src/ # Install app dependencies COPY package.json /usr/src/ RUN npm install --quiet # Bundle app source COPY . /usr/src # Build the project RUN npm run build WORKDIR /usr/src/dist EXPOSE 4895 EXPOSE 5858 CMD [\u0026quot;pm2-docker\u0026quot;, \u0026quot;process.yml\u0026quot;]  Explanation:-\n  Line 1:- We are use Node image having version 8.\n  Line 4:- We globally install gulp and pm2. PM2 is a Production Runtime and Process Manager for Node.js applications with a built-in Load Balancer.\n  Line 7:- We create a new directory /usr/src/ inside our docker image.\n  Line 9:- We set /usr/src/ as our working directory inside the docker image.\n  Line 12:- We copy package.json from root directory to our working directory.\n  Line 14:- We install node modules inside docker image.\n  Line 17:- We copy rest of our code from root directory to our working directory.\n  Line 20:- We build our project using gulp. We already installed gulp inside our docker image in line 4.\n  Line 22:- We set our working directory as /usr/src/dist/ as our JS code is compiled there.\n  Line 26:- We execute pm2 and using our process.yml file that we created earlier to start the application inside docker image.\n  We need to build docker image using this Dockerfile. Add a scripts folder inside root directory and create a dockerCompose.sh file inside it. Copy the following code inside scripts/dockerCompose.sh:\n#!/usr/bin/env bash cd .. docker build -t knrt10/todoapi -f Dockerfile . docker-compose up -d  Add this inside scripts in your package.json.\n\u0026quot;dockerStart\u0026quot;: \u0026quot;cd scripts \u0026amp;\u0026amp; chmod 777 dockerCompose.sh \u0026amp;\u0026amp; ./dockerCompose.sh \u0026amp;\u0026amp; cd ..\u0026quot;, \u0026quot;dockerStop\u0026quot;: \u0026quot;docker-compose down\u0026quot;  Now that you know how to create an image with a Dockerfile, let‚Äôs create an application as a service and connect it to a database. Then we can run some setup commands and be on our way to creating rest of application.\nThe Docker Compose file will define and run the containers based on a configuration file. We are using compose file version 2 syntax, and you can read about it on Docker‚Äôs site.\nAn important concept to understand is that Docker Compose spans buildtime and runtime. Up until now, we have been building images using docker build ., which is buildtime. This is when our containers are actually built. We can think of runtime as what happens once our containers are built and being used.\nCompose triggers buildtime‚Äî instructing our images and containers to build ‚Äî but it also populates data used at runtime, such as env vars and volumes. This is important to be clear on. For instance, when we add things like volumes and command, they will override the same things that may have been set up via the Dockerfile at buildtime.\nOpen your docker-compose.yml file in your editor in root directory and copy/paste the following lines:\nversion: '3' services: web: build: . command: npm run dev volumes: - .:/usr/src/ - /usr/src/node_modules ports: - \u0026quot;3000:3000\u0026quot; depends_on: - mongodb mongodb: image: mongo ports: - \u0026quot;27017:27017\u0026quot; volumes: - ./data:/data/db  Explanation:-\nThe first directive in the web service is to build the image based on our Dockerfile. This will recreate the image we used before, but it will now be named according to the project we are in, graphql-todo. After that, we are giving the service some specific instructions on how it should operate:\n  Line 5:- Once the image is built, and the container is running, the npm start command will start the application.\n  Line 6:- volumes: ‚Äì This section will mount paths between the host and the container.\n  Line 7:- .:/usr/src/ ‚Äì This will mount the root directory to our working directory in the container.\n  Line 8:- /usr/src/node_modules ‚Äì This will mount the node_modules directory to the host machine using the buildtime directory.\n  Line 9:- ports: ‚Äì This will publish the container‚Äôs port, in this case 3000, to the host as port 3000\n  Line 11:- This depicts on what database image it depends on. We are using mongodb so we will specify mongodb\n  Line 14:- It will build mongodb image.\n  Line 15:- Same as nodejs we specify version of mongodb image here.\n  Line 17:- ports: ‚Äì This will publish the container‚Äôs port, in this case 27017, to the host as port 27017\n  Now before executing this script, check your docker is up and running. This command will execute our scripts/dockerCompose.sh file. This file builds our docker image. Now run npm run dockerStart\nIf everything goes right you will see this output. This means your docker image is created.\nSuccessfully built 2597b7c50ed4 Successfully tagged graphql-todo_web:latest Creating graphql-todo_mongodb_1 ... done Creating graphql-todo_web_1 ... done  You can get information about your running containers using the command given below.\ndocker ps -a\nYou will see this kind of output\nCopy the NAMES for image graphql-todo_web and run this\ndocker exec -it graphql-todo_web_1 -- /bin/bash\nThis will run bash inside the existing graphql-todo_web_1 container. The bash process will have the same Linux namespaces as the main container process. This allows you to explore the container from within and see how Node.js and your app see the system when running inside the container. The -it option is shorthand for two options:\n  -i, which makes sure STDIN is kept open. You need this for entering commands into the shell.\n  -t, which allocates a pseudo terminal (TTY).\n  Exploring container from within Now you can run same commands as other users who have node installed. Find your test coverage by running the command given below.\nnpm run coverage\nYou will see the following output.\nYou can stop docker process by running npm run dockerStop after exiting from container.\nSetting up Express server We will now setup our express server. Copy this code to your package.json and run npm i --quiet. Non npm users just copy.\n\u0026quot;dependencies\u0026quot;: { \u0026quot;@types/node\u0026quot;: \u0026quot;^10.12.15\u0026quot;, \u0026quot;bcrypt-nodejs\u0026quot;: \u0026quot;0.0.3\u0026quot;, \u0026quot;bluebird\u0026quot;: \u0026quot;^3.5.3\u0026quot;, \u0026quot;cors\u0026quot;: \u0026quot;^2.8.5\u0026quot;, \u0026quot;express\u0026quot;: \u0026quot;^4.16.4\u0026quot;, \u0026quot;helmet\u0026quot;: \u0026quot;^3.15.0\u0026quot;, \u0026quot;jsonwebtoken\u0026quot;: \u0026quot;^8.4.0\u0026quot;, \u0026quot;mongoose\u0026quot;: \u0026quot;^5.4.0\u0026quot;, \u0026quot;winston\u0026quot;: \u0026quot;2.4.0\u0026quot; }  Explanation:-\n  bcrypt-nodejs:- Its for hashing user password using gensalt and securely storing into database\n  bluebird:- For handling promises.\n  cors:- For handling Cross origin resource sharing and enabling it across all headers and domains.\n  express:- For setting up server.\n  helmet:- For securing our Express apps by setting various HTTP headers.\n  jsonwebtoken:- For creating token that will authenticate the user.\n  mongoose:- An ORM(Object-Relational Mapping) to interact with mongoDB.\n  winston:- A cool logger instead of console.log.\n  Now create a server.ts inside src folder and copy this\n\u0026quot;use strict\u0026quot;; /* Import modules */ import bluebird = require(\u0026quot;bluebird\u0026quot;); import cors = require(\u0026quot;cors\u0026quot;); import express = require(\u0026quot;express\u0026quot;); import fs = require(\u0026quot;fs\u0026quot;); import mongoose = require(\u0026quot;mongoose\u0026quot;); import { Config } from \u0026quot;./shared\u0026quot;; global.Promise = bluebird; /** * @exports TodoApp * @class * @method startServer * @method initEnv * @method initWinston * @method initExpress * @method initCORS * @method initAppRoutes * @method initServices */ export class TodoApp { public infoString: string; public port: any; private pkg = require(\u0026quot;../package.json\u0026quot;); // information about package version private winston: any = require(\u0026quot;winston\u0026quot;); // for logging private app: any; // express server constructor(private portGiven) { if (Config.dbSettings.authEnabled) { this.infoString = \u0026quot;mongodb://\u0026quot; + Config.dbSettings.username + \u0026quot;:\u0026quot; + Config.dbSettings.password + \u0026quot;@\u0026quot; + Config.dbSettings.connectionString + \u0026quot;/\u0026quot; + Config.dbSettings.database; } else if (Config.dbSettings.localDatabase) { this.infoString = \u0026quot;mongodb://\u0026quot; + Config.dbSettings.connectionString + \u0026quot;/\u0026quot; + Config.dbSettings.database; } else { this.infoString = \u0026quot;mongodb://\u0026quot; + Config.dbSettings.dockerconnectionString + \u0026quot;/\u0026quot; + Config.dbSettings.database; } this.port = portGiven; } /** * This starts express server * @method startServer @public */ public startServer() { this.initEnv().then(() =\u0026gt; { // logs/ Folder already // Initilatizing the winston as per documentation this.initWinston(); this.initServices().then(() =\u0026gt; { // start the express server(s) this.initExpress(); // all done this.winston.info(this.pkg.name + \u0026quot; startup sequence completed\u0026quot;, { version: this.pkg.version, }); }); }); } /** * This setups the log folder and any other environment needs * @method initEnv @private * @returns {Promise\u0026lt;void\u0026gt;} */ private initEnv(): Promise\u0026lt;void\u0026gt; { return new Promise\u0026lt;void\u0026gt;((resolve) =\u0026gt; { const logPath: string = Config.serviceSettings.logsDir; fs.stat(logPath, (err) =\u0026gt; { resolve(); }); }); } /** * This Initilatizes the winston * @method initWinston @private */ private initWinston() { // winston is configured as a private variable to the main app.ts // it can then be spread to child modules or routeModules. This way only one winston object needs to be setup this.winston.remove(this.winston.transports.Console); this.winston.add(this.winston.transports.Console, { colorize: true, prettyPrint: true, timestamp: true, }); this.winston.add(this.winston.transports.File, { name: \u0026quot;error\u0026quot;, level: \u0026quot;error\u0026quot;, filename: \u0026quot;logs/error.log\u0026quot;, maxsize: 10485760, maxFiles: \u0026quot;10\u0026quot;, timestamp: true, }); this.winston.add(this.winston.transports.File, { name: \u0026quot;warn\u0026quot;, level: \u0026quot;warn\u0026quot;, filename: \u0026quot;logs/warn.log\u0026quot;, maxsize: 10485760, maxFiles: \u0026quot;10\u0026quot;, timestamp: true, }); this.winston.add(this.winston.transports.File, { name: \u0026quot;info\u0026quot;, level: \u0026quot;info\u0026quot;, filename: \u0026quot;logs/info.log\u0026quot;, maxsize: 10485760, maxFiles: \u0026quot;10\u0026quot;, timestamp: true, }); this.winston.add(this.winston.transports.File, { name: \u0026quot;verbose\u0026quot;, level: \u0026quot;verbose\u0026quot;, filename: \u0026quot;logs/verbose.log\u0026quot;, maxsize: 10485760, maxFiles: \u0026quot;10\u0026quot;, timestamp: true, }); this.winston.info(\u0026quot;Winston has been init\u0026quot;); } /** * This Initilatizes express server * @method initExpress @private */ private initExpress() { // create express this.app = express(); this.initCORS(); // add in any routes you might want this.initAppRoutes(); // and start! this.app.listen(this.port); this.winston.info(\u0026quot;Express started on (http://localhost:\u0026quot; + this.port + \u0026quot;/)\u0026quot;); } /** * This Initilatizes cors package * @method initCORS @private */ private initCORS() { this.app.use(cors()); } /** * This Initilatizes routes for server * @method initAppRoutes @private */ private initAppRoutes() { // We will setup our graphql route here } /** * This Initilatizes services we want if expanding the application * @method initServices @private * @returns {Promise\u0026lt;boolean\u0026gt;} */ private initServices(): Promise\u0026lt;boolean\u0026gt; { return new Promise\u0026lt;boolean\u0026gt;((resolve, reject) =\u0026gt; { // connect to mongodb mongoose.connect(this.infoString, { useNewUrlParser: true }).then(() =\u0026gt; { this.winston.info(\u0026quot;Mongo Connected!\u0026quot;); resolve(true); }); }); } }  Explanation:-\n  Line 1‚Äì10:- We import necessary modules.\n  Line 11:- We specify that our promises globally will be handled by bluebird.\n  Line 24-30:- We create a class TodoApp and initialize it‚Äôs constructor with a public data member infostring and set it to according to what type of mongoDB we are using. If running locally authEnabled is set to false in config.ts file. If running docker localDatabase inside config.ts is set to false.\n  Line 46 :- We create a public member function to start the express server.\n  Line 70‚Äì77:- Here we check whether we have a logs folder or not. We are returning a promise here that we handle in line 47.\n  Line 83‚Äì127:- We are using winston as our logger. So here we setup winston that‚Äôs all.\n  Line 133‚Äì144:- We create a member function to initialize our express application.\n  Line 150‚Äì152:- We are intializing cors module in this member function.\n  Line 158‚Äì160:- In this member function we will initialize our graphQL routes in our next article.\n  Line 167‚Äì175:- In this member function we are returing a promise that resolves to that a mongoDB is connected. We handle this promise on line 52.\n  Now create a shared folder inside src/ and create 2 files\n  config.ts\n  index.ts\n  Copy this to src/shared/config.ts\n/** * This file stores info for api, db, keys, logs * @constant Config */ export const Config = { apiSettings: { host: process.env.API_HOST || \u0026quot;localhost\u0026quot;, }, dbSettings: { authEnabled: process.env.MONGO_AUTH || false, localDatabase: true, dockerconnectionString: process.env.MONGO_DB_HOST_DOCKER || \u0026quot;mongodb:27017\u0026quot;, connectionString: process.env.MONGO_DB_HOST || \u0026quot;localhost:27017\u0026quot;, database: process.env.DATABASE || \u0026quot;todoapp\u0026quot;, password: process.env.MONGO_AUTH_PASSWORD, username: process.env.MONGO_AUTH_USERNAME, }, serviceSettings: { logsDir: \u0026quot;logs/\u0026quot;, env: process.env.environment || \u0026quot;local\u0026quot;, }, secretKeys: { jwtSecret: process.env.SECRET || \u0026quot;yes1234$ASDASD/SA\u0026quot;, cryptoSecret: process.env.CRYPTO || \u0026quot;DASD2233312S;!`W21\u0026quot;, }, };  And this inside src/shared/index.ts\nexport * from \u0026quot;./config\u0026quot;;  Now copy this to your src/app.ts\n\u0026quot;use strict\u0026quot;; import { TodoApp } from \u0026quot;./server\u0026quot;; const server: TodoApp = new TodoApp(process.env.API_PORT || 3000); // starting the server* server.startServer();  Also create a logs folder inside project root directory and create a temp.txt file inside it. Copy the following code inside logs/temp.txt :\nThis is just an example of log file\n{\u0026quot;level\u0026quot;:\u0026quot;info\u0026quot;,\u0026quot;message\u0026quot;:\u0026quot;Winston has been init\u0026quot;,\u0026quot;timestamp\u0026quot;:\u0026quot;2018-12-26T16:59:05.380Z\u0026quot;} {\u0026quot;level\u0026quot;:\u0026quot;info\u0026quot;,\u0026quot;message\u0026quot;:\u0026quot;Mongo Connected!\u0026quot;,\u0026quot;timestamp\u0026quot;:\u0026quot;2018-12-26T16:59:05.420Z\u0026quot;} {\u0026quot;level\u0026quot;:\u0026quot;info\u0026quot;,\u0026quot;message\u0026quot;:\u0026quot;Express started on ([http://localhost:3000/](http://localhost:3000/))\u0026quot;,\u0026quot;timestamp\u0026quot;:\u0026quot;2018-12-26T16:59:05.430Z\u0026quot;} {\u0026quot;version\u0026quot;:\u0026quot;1.0.0\u0026quot;,\u0026quot;level\u0026quot;:\u0026quot;info\u0026quot;,\u0026quot;message\u0026quot;:\u0026quot;graphql-todo startup sequence completed\u0026quot;,\u0026quot;timestamp\u0026quot;:\u0026quot;2018-12-26T16:59:05.432Z\u0026quot;}  To update our tests. Copy this to src/test/user-test.spec.ts :\nimport chai = require(\u0026quot;chai\u0026quot;); import chaiAsPromised = require(\u0026quot;chai-as-promised\u0026quot;); import chaiHttp = require(\u0026quot;chai-http\u0026quot;); import { suite, test } from \u0026quot;mocha-typescript\u0026quot;; import sinon = require(\u0026quot;sinon\u0026quot;); import { TodoApp } from \u0026quot;../server\u0026quot;; import { Config } from \u0026quot;../shared\u0026quot;; // starting the server const server: TodoApp = new TodoApp(process.env.API_PORT || 3001); server.startServer(); chai.use(chaiAsPromised); chai.use(chaiHttp); @suite(\u0026quot;User Test class\u0026quot;) class UserTests { static after() { process.exit(0); } @test(\u0026quot;Testing Local Connection - try connection for Local mongodb\u0026quot;) public localDb(done) { setTimeout(() =\u0026gt; { Config.dbSettings.localDatabase = true; const mock = sinon.mock(new TodoApp(process.env.API_PORT || 3001), \u0026quot;constructor\u0026quot;); chai.expect(mock.object.infoString).to.deep.equal(\u0026quot;mongodb://\u0026quot; + Config.dbSettings.connectionString + \u0026quot;/\u0026quot; + Config.dbSettings.database); done(); }, 100); } @test(\u0026quot;Testing Docker Connection - try connection for docker mongodb\u0026quot;) public dockerDb(done) { Config.dbSettings.localDatabase = false; const mock = sinon.mock(new TodoApp(process.env.API_PORT || 3001), \u0026quot;constructor\u0026quot;); chai.expect(mock.object.infoString).to.deep.equal(\u0026quot;mongodb://\u0026quot; + Config.dbSettings.dockerconnectionString + \u0026quot;/\u0026quot; + Config.dbSettings.database); done(); } @test(\u0026quot;Testing Online Connection - try connection for online mongodb\u0026quot;) public OnlineDb(done) { Config.dbSettings.authEnabled = true; const mock = sinon.mock(new TodoApp(process.env.API_PORT || 3001), \u0026quot;constructor\u0026quot;); chai.expect(mock.object.infoString).to.deep.equal(\u0026quot;mongodb://\u0026quot; + Config.dbSettings.username + \u0026quot;:\u0026quot; + Config.dbSettings.password + \u0026quot;@\u0026quot; + Config.dbSettings.connectionString + \u0026quot;/\u0026quot; + Config.dbSettings.database); done(); } }  First start your mongoDB for your OS and then run npm run build \u0026amp;\u0026amp; npm run coverage. You will see the output given below.\n second set of tests with maintained üíØ code coverage. üëå\n Commiting our changes We need to commit our changes, so that if some problem occur we can roll back to this commit. First create a .gitignore file in your root directory and copy this\n*# Dependency directories* node_modules jspm_packages *# Optional npm cache directory *.npm *# Optional REPL history *.node_repl_history /bin/ /tmp/ /dist/ /typings/ /data/ /logs/*.log /.nyc_output/ /coverage/ .DS_Store package-lock.json  Now copy and run the commands given below inside your git repository. Make sure you are in root folder.\ngit add . git commit -m \u0026quot;Adding part1 changes\u0026quot;  So far your project should look like this\nConclusion That is for this part. In this part you learnt following things:-\n  How to create express server.\n  How to setup docker using dockerfile and docker-compose.yml.\n  How to use Gulp and compile code from TS to JS.\n  How to write clean code.\n  How and write tests and have üíØ code coverage üòÉ.\n  In next part you will start working with graphQL and make API using that.\n  Did you find this page helpful? Consider sharing it üôå ","date":1546041600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1608892755,"objectID":"7cdc6e2ea5c8dd3618626d0db71bc429","permalink":"/post/part-1-api-using-graphql/","publishdate":"2018-12-29T00:00:00Z","relpermalink":"/post/part-1-api-using-graphql/","section":"post","summary":"This is a series of 3 articles which will help to write production grade code.","tags":["js","opensource","node.js","docker","mongodb","testing"],"title":"Part 1:- API using GraphQL and Node.js","type":"post"},{"authors":["Kautilya Tripathi"],"categories":["opensource"],"content":"A little background For months my eyes were set on one goal¬†: the prestigious and famous Google Summer of Code. I had been contributing to my organization like crazy, creating PRs after PRs, raising issues and helping out fellow contributors and other aspiring GSoCers on the community\u0026rsquo;s slack team.\nThe day of the results came and out of the two slots given to my organization my project wasn\u0026rsquo;t in the list of selected projects. It was hard at first, I thought I had done everything right but still my name wasn\u0026rsquo;t up there.\nThe next morning I decided not to waste my time anymore and started to look at the bright side of things, contributing to open source project helped me learn invaluable skills like test driven development, CI/CD, git (rebasing, merge conflicts), etc. I may not be getting any stipend for writing code throughout the summer but I earned some invaluable skills which I can use in my future projects.\nSo it was exam time and I was hacking on one of my project‚Äôs as usual (a CLI tool to upload images to a cloud service) when one of my cool friends (Palash Nigam) entered my room and said with a tone of surprise ‚ÄúYou don‚Äôt know how to touch type? That‚Äôs pathetic‚Äù üòÄ. So he introduced me to this site called typeracer (so I listened to him and started practicing on that site and I was hooked). One of my seniors from college (Shibasis Patel) gave me this idea of creating a CLI tool to play typeracer (as I had earlier asked him for some project ideas) which we could use to introduce the freshmen to both the shell and touch typing. This gave me a new purpose, so I started coding. After about a week of writing code I am proud to present to you typeracer-CLI\nWhat is typeracer-cli? So it is basically a terminal client for playing typeracer on your shell. As soon as you start the game you will be presented with a paragraph which you have to type out and at the end your time and speed (in wpm) are recorded and presented as an output.\n What‚Äôs new about this? CLI versions of this game already exist. Agreed, other versions of this already exists but they don‚Äôt offer all the features that this client does, like:\n  Practice mode (offline mode) User stats (words per minute, time taken) Online mode (have a type-race by spawning up a server and sharing it with your friends) Ask for a rematch after the race ends (online mode) View the top 10 High scores in online mode  The motivation behind it Well, they say failure is a great motivator. I learned this the hard way. Failing in getting selected for GSoC motivated me even more to be a better developer. The other big reason was the desire to do something for my college. I had realized the benefits of working in a developer community during the time I was preparing for GSoC. Although I was a part of my college‚Äôs Programming Society I hadn‚Äôt contributed as actively as I should have. This project turned out to be one of the ways of contributing to my community by spreading awareness about touch typing and CLI tools among young aspiring developers who are just starting out.\nImplementation Initially the task was to get keystrokes from the user‚Äôs terminal which at that time I thought was impossible. But I found about readline and keyspress events in nodejs which helped me to move further in coding.\nThe tasks were broken up into the following:\n Conver this tool to an npm package Offline practice mode Generate random paragraph for every race Add more sensible paragraphs Display the user‚Äôs time and speed as they type Setup server for online mode Improve the API Design Write tests  Getting into every point in detail Converting it to an npm package This was important task so that one can easily download the package and install it globally from npm. For that we need to use a very important line on the start of the file that is going to execute.\n #!/usr/bin/env node is an instance of a shebang line: the very first line in an executable plain-text file on Unix-like platforms that tells the system what interpreter to pass that file to for execution, via the command line following the magic #! prefix (called shebang)\n Although Windows does not support shebang lines, so they‚Äôre effectively ignored there; on Windows it is solely a given file‚Äôs filename extension that determines what executable will interpret it. However, you still need them in the context of npm.\nImplementing the offline (practice) mode Initially some commands were written for the execution of practice mode. With the help of a package commander I was able to achieve this task.\nprogram .command('practice') .alias('p') .description('Starts typeracer in practice mode') .action(() =\u0026gt; { game() })  game() function This is main logic that allows the application to get keystrokes from the client, but we also have to listen to keypress event for completion of this task. stdin.on('keypress', keypress)\nconst stdin = process.stdin const stdout = process.stdout stdin.setRawMode(true) stdin.resume() require('readline').emitKeypressEvents(stdin)  Now in game() I was enabling keypress event after 5 seconds of game, and showing paragraphs to user so that they get time to relax their fingers, twist turn their neck, crack their knuckles and say ‚Äúbring it on‚Äù.\nI was displaying three things to client when they were typing\n Real time analysis of their typing with green, red representing correct and wrong characters respectively.  /** * @function color * @param {String} quote * @param {String} stringTyped */ function color (quote, stringTyped) { let colouredString = '' let wrongInput = false const quoteLetters = quote.split('') const typedLetters = stringTyped.split('') for (let i = 0; i \u0026lt; typedLetters.length; i++) { // if a single mistake, // the rest of the coloured string will appear red if (wrongInput) { colouredString += chalk.bgRed(quoteLetters[i]) continue } if (typedLetters[i] === quoteLetters[i]) { wrongInput = false colouredString += chalk.green(quoteLetters[i]) if (quote === stringTyped) { gameEnd = true } } else { wrongInput = true colouredString += chalk.bgRed(quoteLetters[i]) } } return colouredString }   Real time analysis of their speed in words per minute.  The following snippet explains how to get the speed of a user according to correct words typed by them.\n/** * @function updateWpm */ function updateWpm () { if (stringTyped.length \u0026gt; 0) { wordsPermin = stringTyped.split(' ').length / (time / 60) } }   Calculating the time taken  /** * @function Time */ function Time () { time = (Date.now() - timeStarted) / 1000 }  In the end there is an option to retry where you can restart the match with generation of new paragraph every time.\nOnline Mode This was very important feature to implement as this sets this client apart from other CLI versions. This was implemented using socket.io accordingly:\n Creating a server Connecting clients to the server Create private room for competition Send scores to all clients at end of game Rematch feature Random paragraphs for every race Top 10 high scores  Getting into every point in detail Creating a server I am quite fluent with Javascript and NodeJs, so I used NodeJs for creating server of the application and hosted in on Glitch.\nSocket.io was used to provide web sockets for clients to connect and emit events for server to listen. MongoDB was used as database for storing top 10 high scores of clients.\nConnecting clients to sever Initially the client part was quite tricky as I had not understood socket.io upto basic level. At first I was working on local server or you can localhost. I was using socket.io client for client side but still took me a whole day to understand the basic and connect a client to the server.\nCreating a private room for competition Now in socket.io you can create different namespace or you can say rooms to join. So I had to get some input from user to create a private channel where they can race otherwise it would create countless problems. I used the crypto node module to provide cryptographic functionality that includes a set of wrappers for OpenSSL‚Äôs hash, HMAC, cipher, decipher, sign, and verify functions and generated random strings with it every time.\nconst roomNumber = crypto .randomBytes(12) .toString('base64') .replace(/[+/=]+/g, '')  Another problem was how the server would know the number of players in a room so that it can emit an event for race to start. For that I asked number of players from client they wanted to race with (using the npm package inquirer.)\nSo when the user joined the room I emitted all the information of client to sever so that it can work according to that.\n// Emitting client info on joining the room _socket.on('room', function (val) { _socket.emit('join', {roomName: val.value, username: data.username, number: data.number, randomNumber: data.randomNumber}) })  Now when the server knew that all the clients have joined the race it emitted an event to clients and started the race. It was important to send random paragraphs on every connection and also same paragraph to all clients in a same room.\n/** * @function randomNumRetry */ function randomNumRetry () { randomNumber = Math.floor((Math.random() * paras.length)) quote = paras[randomNumber].para if (quote.length \u0026lt; 100) { quote = paras[randomNumber].para + ' ' + paras[randomNumber - 1].para } return quote }  When everything was in order and every client completed the race, the server emitted an event sending all the scores to every client and asking if they wanted a rematch. Similarly for a rematch random paragraph was generated.\nTop 10 high scores For this feature to work I initially created a shell database with ten anonymous users with their scores initialized to 0. Now whenever someone plays an online game and score greater than 10th highest score in database, it replaces the 10th highest scorer with the user in the database (this was done to avoid excessive use of database).\n// Getting documents from databse Score.findOne({_id: process.env.ID}, (err, players) =\u0026gt; { if (err) throw new Error(err) let playersArray = players.players.sort(function (a, b) { return b.score - a.score }) let lowestScore = [] lowestScore.push(playersArray[playersArray.length - 1].score) // checking if last score is less then current score function remove () { // First removing last player Score.update({_id: process.env.ID}, {$pop: {players: 1}}, (err) =\u0026gt; { if (err) throw new Error(err) console.log('Removed last player') }) } function add () { // Then updating current player Score.update({_id: process.env.ID}, {$push: {players: {score, username}}}, (err) =\u0026gt; { if (err) throw new Error(err) console.log('Added new High score') }) } async function update () { // Then again sorting it correctly await Score.update({_id: process.env.ID}, {$push: {players: {$each: [], $sort: -1}}}, (err) =\u0026gt; { if (err) throw new Error(err) console.log('Sorted in descending order after adding') }) } if (score \u0026gt; lowestScore[0]) { (async () =\u0026gt; { Promise.all([update()]).then(async () =\u0026gt; { await remove() await add() await update() }) })() } })  Support Us This project was a great learning experience for me and we (my friends and I) are looking to build more such awesome projects in the future. We are a bunch of undergrads passionate about software development looking to make cool stuff. A little motivation and support helps us a lot. If you like this nifty hack you can support us by doing any (or all üòâ ) of the following:\n ‚≠êÔ∏è Star us on Github and make it trend so that other people can know about our project. Install it and increase our download count on npm. Tweet about it (our handle is psociiit).  Thanks to Palash Nigam for helping me to write this article and also Shibasis Patel for sharing this cool idea.\nDid you find this page helpful? Consider sharing it üôå ","date":1526256000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1608887602,"objectID":"61351d3ce18d88d2104d237518b8cb87","permalink":"/post/typeracer/","publishdate":"2018-05-14T00:00:00Z","relpermalink":"/post/typeracer/","section":"post","summary":"Why I created a typeracing application.","tags":["js","opensource","node.js","touchtyping"],"title":"ShellRacer","type":"post"}]